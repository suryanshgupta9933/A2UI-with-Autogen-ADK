{"version":3,"file":"watch.js","sourceRoot":"","sources":["../../src/lib/watch.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAwB,SAAS,EAAC,MAAM,kBAAkB,CAAC;AAClE,OAAO,EAAC,cAAc,EAAC,MAAM,wBAAwB,CAAC;AACtD,OAAO,EAAC,MAAM,EAAC,MAAM,iBAAiB,CAAC;AAGvC,MAAM,OAAO,cAAkB,SAAQ,cAAc;IAW3C,OAAO;QACb,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;YACjC,OAAO;QACT,CAAC;QACD,IAAI,CAAC,UAAU,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE;;YACzC,OAAO,MAAA,IAAI,CAAC,QAAQ,0CAAE,GAAG,EAAE,CAAC;QAC9B,CAAC,CAAC,CAAC;QACH,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;;YAC/D,sEAAsE;YACtE,yBAAyB;YACzB,MAAA,IAAI,CAAC,MAAM,0CAAE,qBAAqB,CAAC,IAA+B,CAAC,CAAC;YACpE,OAAO,CAAC,KAAK,EAAE,CAAC;QAClB,CAAC,CAAC,CAAC,CAAC;QACJ,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACjC,CAAC;IAEO,SAAS;;QACf,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;YACjC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,UAAW,CAAC,CAAC;YACzC,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;YAC5B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,MAAA,IAAI,CAAC,MAAM,0CAAE,oBAAoB,CAAC,IAA+B,CAAC,CAAC;QACrE,CAAC;IACH,CAAC;IAED,MAAM;QACJ,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,WAAC,OAAA,MAAA,IAAI,CAAC,UAAU,0CAAE,GAAG,EAAE,CAAA,EAAA,CAAC,CAAC,CAAC;IACrE,CAAC;IAED,MAAM,CAAC,MAA4C;QACjD,uEAAuE;QACvE,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;IACnD,CAAC;IAEQ,MAAM,CACb,IAAU,EACV,CAAC,MAAM,CAAiD;;QAExD,MAAA,IAAI,CAAC,MAAM,oCAAX,IAAI,CAAC,MAAM,GAAK,MAAA,IAAI,CAAC,OAAO,0CAAE,IAAqB,EAAC;QACpD,IAAI,MAAM,KAAK,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;YAC5D,yBAAyB;YACzB,IAAI,CAAC,SAAS,EAAE,CAAC;QACnB,CAAC;QACD,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;QACvB,IAAI,CAAC,OAAO,EAAE,CAAC;QAEf,2EAA2E;QAC3E,0EAA0E;QAC1E,yEAAyE;QACzE,yEAAyE;QACzE,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,UAAW,CAAC,GAAG,EAAE,CAAC,CAAC;IAC7D,CAAC;IAEkB,YAAY;QAC7B,IAAI,CAAC,SAAS,EAAE,CAAC;IACnB,CAAC;IAEkB,WAAW;QAC5B,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;CACF;AAMD;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,KAAK,GAAG,SAAS,CAAC,cAAc,CAA2B,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {DirectiveResult, Part, directive} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {Signal} from 'signal-polyfill';\nimport {SignalWatcher} from './signal-watcher.js';\n\nexport class WatchDirective<T> extends AsyncDirective {\n  private __host?: SignalWatcher;\n\n  private __signal?: Signal.State<T> | Signal.Computed<T>;\n\n  private __watcher?: Signal.subtle.Watcher;\n\n  // We have to wrap the signal in a computed to work around a bug in the\n  // signal-polyfill: https://github.com/proposal-signals/signal-polyfill/issues/27\n  private __computed?: Signal.Computed<T | undefined>;\n\n  private __watch() {\n    if (this.__watcher !== undefined) {\n      return;\n    }\n    this.__computed = new Signal.Computed(() => {\n      return this.__signal?.get();\n    });\n    const watcher = (this.__watcher = new Signal.subtle.Watcher(() => {\n      // TODO: If we're not running inside a SignalWatcher, we can commit to\n      // the DOM independently.\n      this.__host?._updateWatchDirective(this as WatchDirective<unknown>);\n      watcher.watch();\n    }));\n    watcher.watch(this.__computed);\n  }\n\n  private __unwatch() {\n    if (this.__watcher !== undefined) {\n      this.__watcher.unwatch(this.__computed!);\n      this.__computed = undefined;\n      this.__watcher = undefined;\n      this.__host?._clearWatchDirective(this as WatchDirective<unknown>);\n    }\n  }\n\n  commit() {\n    this.setValue(Signal.subtle.untrack(() => this.__computed?.get()));\n  }\n\n  render(signal: Signal.State<T> | Signal.Computed<T>): T {\n    // This would only be called if render is called directly, like in SSR.\n    return Signal.subtle.untrack(() => signal.get());\n  }\n\n  override update(\n    part: Part,\n    [signal]: [signal: Signal.State<T> | Signal.Computed<T>]\n  ) {\n    this.__host ??= part.options?.host as SignalWatcher;\n    if (signal !== this.__signal && this.__signal !== undefined) {\n      // Unwatch the old signal\n      this.__unwatch();\n    }\n    this.__signal = signal;\n    this.__watch();\n\n    // We use untrack() so that the signal access is not tracked by the watcher\n    // created by SignalWatcher. This means that an can use both SignalWatcher\n    // and watch() and a signal update won't trigger a full element update if\n    // it's only passed to watch() and not otherwise accessed by the element.\n    return Signal.subtle.untrack(() => this.__computed!.get());\n  }\n\n  protected override disconnected(): void {\n    this.__unwatch();\n  }\n\n  protected override reconnected(): void {\n    this.__watch();\n  }\n}\n\nexport type WatchDirectiveFunction = <T>(\n  signal: Signal.State<T> | Signal.Computed<T>\n) => DirectiveResult<typeof WatchDirective<T>>;\n\n/**\n * Renders a signal and subscribes to it, updating the part when the signal\n * changes.\n *\n * watch() can only be used in a reactive element that applies the\n * SignalWatcher mixin.\n */\nexport const watch = directive(WatchDirective) as WatchDirectiveFunction;\n"]}