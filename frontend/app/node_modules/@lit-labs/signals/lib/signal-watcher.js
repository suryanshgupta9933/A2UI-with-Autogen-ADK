import{Signal as t}from"signal-polyfill";
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const i=Symbol("SignalWatcherBrand"),s=new FinalizationRegistry((({watcher:t,signal:i})=>{t.unwatch(i)})),h=new WeakMap;function e(e){return!0===e[i]?(console.warn("SignalWatcher should not be applied to the same class more than once."),e):class extends e{constructor(){super(...arguments),this._$St=new t.State(0),this._$Si=!1,this._$So=!0,this._$Sh=new Set}_$Sl(){if(void 0!==this._$Su)return;this._$Sv=new t.Computed((()=>{this._$St.get(),super.performUpdate()}));const i=this._$Su=new t.subtle.Watcher((function(){const t=h.get(this);void 0!==t&&(!1===t._$Si&&t.requestUpdate(),this.watch())}));h.set(i,this),s.register(this,{watcher:i,signal:this._$Sv}),i.watch(this._$Sv)}_$Sp(){void 0!==this._$Su&&(this._$Su.unwatch(this._$Sv),this._$Sv=void 0,this._$Su=void 0)}performUpdate(){this.isUpdatePending&&(this._$Sl(),this._$Si=!0,this._$St.set(this._$St.get()+1),this._$Si=!1,this._$Sv.get())}update(t){try{this._$So?(this._$So=!1,super.update(t)):this._$Sh.forEach((t=>t.commit()))}finally{this.isUpdatePending=!1,this._$Sh.clear()}}requestUpdate(t,i,s){this._$So=!0,super.requestUpdate(t,i,s)}connectedCallback(){super.connectedCallback(),this.requestUpdate()}disconnectedCallback(){super.disconnectedCallback(),queueMicrotask((()=>{!1===this.isConnected&&this._$Sp()}))}_(t){this._$Sh.add(t);const i=this._$So;this.requestUpdate(),this._$So=i}m(t){this._$Sh.delete(t)}}}export{e as SignalWatcher};
//# sourceMappingURL=signal-watcher.js.map
