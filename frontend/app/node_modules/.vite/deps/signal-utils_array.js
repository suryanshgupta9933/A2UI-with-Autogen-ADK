import {
  createStorage
} from "./chunk-IV7QRA2E.js";
import "./chunk-ZDAEO5LF.js";
import "./chunk-PZ5AY32C.js";

// ../packages/lit/node_modules/signal-utils/dist/array.ts.js
var ARRAY_GETTER_METHODS = /* @__PURE__ */ new Set([Symbol.iterator, "concat", "entries", "every", "filter", "find", "findIndex", "flat", "flatMap", "forEach", "includes", "indexOf", "join", "keys", "lastIndexOf", "map", "reduce", "reduceRight", "slice", "some", "values"]);
var ARRAY_WRITE_THEN_READ_METHODS = /* @__PURE__ */ new Set(["fill", "push", "unshift"]);
function convertToInt(prop) {
  if (typeof prop === "symbol") return null;
  const num = Number(prop);
  if (isNaN(num)) return null;
  return num % 1 === 0 ? num : null;
}
var SignalArray = class _SignalArray {
  /**
   * Creates an array from an iterable object.
   * @param iterable An iterable object to convert to an array.
   */
  /**
   * Creates an array from an iterable object.
   * @param iterable An iterable object to convert to an array.
   * @param mapfn A mapping function to call on every element of the array.
   * @param thisArg Value of 'this' used to invoke the mapfn.
   */
  static from(iterable, mapfn, thisArg) {
    return mapfn ? new _SignalArray(Array.from(iterable, mapfn, thisArg)) : new _SignalArray(Array.from(iterable));
  }
  static of(...arr) {
    return new _SignalArray(arr);
  }
  constructor(arr = []) {
    let clone = arr.slice();
    let self = this;
    let boundFns = /* @__PURE__ */ new Map();
    let nativelyAccessingLengthFromPushOrUnshift = false;
    return new Proxy(clone, {
      get(target, prop) {
        let index = convertToInt(prop);
        if (index !== null) {
          self.#readStorageFor(index);
          self.#collection.get();
          return target[index];
        }
        if (prop === "length") {
          if (nativelyAccessingLengthFromPushOrUnshift) {
            nativelyAccessingLengthFromPushOrUnshift = false;
          } else {
            self.#collection.get();
          }
          return target[prop];
        }
        if (ARRAY_WRITE_THEN_READ_METHODS.has(prop)) {
          nativelyAccessingLengthFromPushOrUnshift = true;
        }
        if (ARRAY_GETTER_METHODS.has(prop)) {
          let fn = boundFns.get(prop);
          if (fn === void 0) {
            fn = (...args) => {
              self.#collection.get();
              return target[prop](...args);
            };
            boundFns.set(prop, fn);
          }
          return fn;
        }
        return target[prop];
      },
      set(target, prop, value) {
        target[prop] = value;
        let index = convertToInt(prop);
        if (index !== null) {
          self.#dirtyStorageFor(index);
          self.#collection.set(null);
        } else if (prop === "length") {
          self.#collection.set(null);
        }
        return true;
      },
      getPrototypeOf() {
        return _SignalArray.prototype;
      }
    });
  }
  #collection = createStorage();
  #storages = /* @__PURE__ */ new Map();
  #readStorageFor(index) {
    let storage = this.#storages.get(index);
    if (storage === void 0) {
      storage = createStorage();
      this.#storages.set(index, storage);
    }
    storage.get();
  }
  #dirtyStorageFor(index) {
    const storage = this.#storages.get(index);
    if (storage) {
      storage.set(null);
    }
  }
};
Object.setPrototypeOf(SignalArray.prototype, Array.prototype);
function signalArray(x) {
  return new SignalArray(x);
}
export {
  SignalArray,
  signalArray
};
//# sourceMappingURL=signal-utils_array.js.map
