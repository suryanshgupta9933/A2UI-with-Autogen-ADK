{
  "version": 3,
  "sources": ["../../../../packages/lit/node_modules/signal-utils/src/object.ts"],
  "sourcesContent": ["import { Signal } from \"signal-polyfill\";\nimport { createStorage } from \"./-private/util.ts\";\n\n/**\n * Implementation based of tracked-built-ins' TrackedObject\n * https://github.com/tracked-tools/tracked-built-ins/blob/master/addon/src/-private/object.js\n */\nexport class SignalObjectImpl {\n  static fromEntries<T = unknown>(\n    entries: Iterable<readonly [PropertyKey, T]>,\n  ) {\n    return new SignalObjectImpl(Object.fromEntries(entries)) as T;\n  }\n  #storages = new Map<PropertyKey, Signal.State<null>>();\n  #collection = createStorage();\n\n  constructor(obj = {}) {\n    let proto = Object.getPrototypeOf(obj);\n    let descs = Object.getOwnPropertyDescriptors(obj);\n\n    let clone = Object.create(proto);\n\n    for (let prop in descs) {\n      // SAFETY: we just iterated over the property, so having to do an\n      //         existence check here is a little silly\n      Object.defineProperty(clone, prop, descs[prop]!);\n    }\n\n    let self = this;\n\n    return new Proxy(clone, {\n      get(target, prop, receiver) {\n        // we don't use the signals directly\n        // because we don't know (nor care!) what the value would be\n        // and the value could be replaced\n        // (this is also important for supporting getters)\n        self.#readStorageFor(prop);\n\n        return Reflect.get(target, prop, receiver);\n      },\n\n      has(target, prop) {\n        self.#readStorageFor(prop);\n\n        return prop in target;\n      },\n\n      ownKeys(target) {\n        self.#collection.get();\n\n        return Reflect.ownKeys(target);\n      },\n\n      set(target, prop, value, receiver) {\n        let result = Reflect.set(target, prop, value, receiver);\n\n        self.#dirtyStorageFor(prop);\n        self.#dirtyCollection();\n\n        return result;\n      },\n\n      deleteProperty(target, prop) {\n        if (prop in target) {\n          delete target[prop];\n          self.#dirtyStorageFor(prop);\n          self.#dirtyCollection();\n        }\n\n        return true;\n      },\n\n      getPrototypeOf() {\n        return SignalObjectImpl.prototype;\n      },\n    });\n  }\n\n  #readStorageFor(key: PropertyKey) {\n    let storage = this.#storages.get(key);\n\n    if (storage === undefined) {\n      storage = createStorage();\n      this.#storages.set(key, storage);\n    }\n\n    storage.get();\n  }\n\n  #dirtyStorageFor(key: PropertyKey) {\n    const storage = this.#storages.get(key);\n\n    if (storage) {\n      storage.set(null);\n    }\n  }\n\n  #dirtyCollection() {\n    this.#collection.set(null);\n  }\n}\n\ninterface SignalObject {\n  fromEntries<T = unknown>(\n    entries: Iterable<readonly [PropertyKey, T]>,\n  ): { [k: string]: T };\n\n  new <T extends Record<PropertyKey, unknown> = Record<PropertyKey, unknown>>(\n    obj?: T,\n  ): T;\n}\n// Types are too hard in proxy-implementation\n// we want TS to think the SignalObject is Object-like\n\n/**\n * Create a reactive Object, backed by Signals, using a Proxy.\n * This allows dynamic creation and deletion of signals using the object primitive\n * APIs that most folks are familiar with -- the only difference is instantiation.\n * ```js\n * const obj = new SignalObject({ foo: 123 });\n *\n * obj.foo // 123\n * obj.foo = 456\n * obj.foo // 456\n * obj.bar = 2\n * obj.bar // 2\n * ```\n */\nexport const SignalObject: SignalObject =\n  SignalObjectImpl as unknown as SignalObject;\n\nexport function signalObject<T extends Record<PropertyKey, unknown>>(\n  obj?: T | undefined,\n) {\n  return new SignalObject(obj);\n}\n"],
  "mappings": ";;;;;;;AAOO,IAAMA,mBAAN,MAAMA,kBAAiB;EAC5B,OAAOC,YACLC,SACA;AACA,WAAO,IAAIF,kBAAiBG,OAAOF,YAAYC,OAAO,CAAC;EACzD;EACA,YAAY,oBAAIE,IAAG;EACnB,cAAcC,cAAa;EAE3BC,YAAYC,MAAM,CAAA,GAAI;AACpB,QAAIC,QAAQL,OAAOM,eAAeF,GAAG;AACrC,QAAIG,QAAQP,OAAOQ,0BAA0BJ,GAAG;AAEhD,QAAIK,QAAQT,OAAOU,OAAOL,KAAK;AAE/B,aAASM,QAAQJ,OAAO;AAGtBP,aAAOY,eAAeH,OAAOE,MAAMJ,MAAMI,IAAI,CAAE;IACjD;AAEA,QAAIE,OAAO;AAEX,WAAO,IAAIC,MAAML,OAAO;MACtBM,IAAIC,QAAQL,MAAMM,UAAU;AAK1BJ,aAAK,gBAAgBF,IAAI;AAEzB,eAAOO,QAAQH,IAAIC,QAAQL,MAAMM,QAAQ;;MAG3CE,IAAIH,QAAQL,MAAM;AAChBE,aAAK,gBAAgBF,IAAI;AAEzB,eAAOA,QAAQK;;MAGjBI,QAAQJ,QAAQ;AACdH,aAAK,YAAYE,IAAG;AAEpB,eAAOG,QAAQE,QAAQJ,MAAM;;MAG/BK,IAAIL,QAAQL,MAAMW,OAAOL,UAAU;AACjC,YAAIM,SAASL,QAAQG,IAAIL,QAAQL,MAAMW,OAAOL,QAAQ;AAEtDJ,aAAK,iBAAiBF,IAAI;AAC1BE,aAAK,iBAAgB;AAErB,eAAOU;;MAGTC,eAAeR,QAAQL,MAAM;AAC3B,YAAIA,QAAQK,QAAQ;AAClB,iBAAOA,OAAOL,IAAI;AAClBE,eAAK,iBAAiBF,IAAI;AAC1BE,eAAK,iBAAgB;QACvB;AAEA,eAAO;;MAGTP,iBAAiB;AACf,eAAOT,kBAAiB4B;MAC1B;IACF,CAAC;EACH;EAEA,gBAAgBC,KAAkB;AAChC,QAAIC,UAAU,KAAK,UAAUZ,IAAIW,GAAG;AAEpC,QAAIC,YAAYC,QAAW;AACzBD,gBAAUzB,cAAa;AACvB,WAAK,UAAUmB,IAAIK,KAAKC,OAAO;IACjC;AAEAA,YAAQZ,IAAG;EACb;EAEA,iBAAiBW,KAAkB;AACjC,UAAMC,UAAU,KAAK,UAAUZ,IAAIW,GAAG;AAEtC,QAAIC,SAAS;AACXA,cAAQN,IAAI,IAAI;IAClB;EACF;EAEA,mBAAmB;AACjB,SAAK,YAAYA,IAAI,IAAI;EAC3B;AACF;AA4BO,IAAMQ,eACXhC;AAEK,SAASiC,aACd1B,KACA;AACA,SAAO,IAAIyB,aAAazB,GAAG;AAC7B;",
  "names": ["SignalObjectImpl", "fromEntries", "entries", "Object", "Map", "createStorage", "constructor", "obj", "proto", "getPrototypeOf", "descs", "getOwnPropertyDescriptors", "clone", "create", "prop", "defineProperty", "self", "Proxy", "get", "target", "receiver", "Reflect", "has", "ownKeys", "set", "value", "result", "deleteProperty", "prototype", "key", "storage", "undefined", "SignalObject", "signalObject"]
}
