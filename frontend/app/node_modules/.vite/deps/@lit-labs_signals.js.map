{
  "version": 3,
  "sources": ["../../signal-polyfill/dist/index.js", "../../@lit-labs/signals/src/lib/signal-watcher.ts", "../../@lit-labs/signals/src/lib/watch.ts", "../../@lit-labs/signals/src/lib/html-tag.ts", "../../@lit-labs/signals/src/index.ts"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateIn = (member, obj) => {\n  if (Object(obj) !== obj)\n    throw TypeError('Cannot use the \"in\" operator on this value');\n  return member.has(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\nlet epoch = 1;\nconst SIGNAL = /* @__PURE__ */ Symbol(\"SIGNAL\");\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producerNode: void 0,\n  producerLastReadVersion: void 0,\n  producerIndexOfThis: void 0,\n  nextProducerIndex: 0,\n  liveConsumerNode: void 0,\n  liveConsumerIndexOfThis: void 0,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {\n  },\n  consumerMarkedDirty: () => {\n  },\n  consumerOnSignalRead: () => {\n  }\n};\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(\n      typeof ngDevMode !== \"undefined\" && ngDevMode ? `Assertion error: signal read during notification phase` : \"\"\n    );\n  }\n  if (activeConsumer === null) {\n    return;\n  }\n  activeConsumer.consumerOnSignalRead(node);\n  const idx = activeConsumer.nextProducerIndex++;\n  assertConsumerNode(activeConsumer);\n  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode[idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n    }\n  }\n  if (activeConsumer.producerNode[idx] !== node) {\n    activeConsumer.producerNode[idx] = node;\n    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n  }\n  activeConsumer.producerLastReadVersion[idx] = node.version;\n}\nfunction producerIncrementEpoch() {\n  epoch++;\n}\nfunction producerUpdateValueVersion(node) {\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n    return;\n  }\n  node.producerRecomputeValue(node);\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\nfunction producerNotifyConsumers(node) {\n  if (node.liveConsumerNode === void 0) {\n    return;\n  }\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\nfunction producerUpdatesAllowed() {\n  return (activeConsumer == null ? void 0 : activeConsumer.consumerAllowSignalWrites) !== false;\n}\nfunction consumerMarkDirty(node) {\n  var _a;\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  (_a = node.consumerMarkedDirty) == null ? void 0 : _a.call(node.wrapper ?? node);\n}\nfunction consumerBeforeComputation(node) {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {\n    return;\n  }\n  if (consumerIsLive(node)) {\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion.pop();\n    node.producerIndexOfThis.pop();\n  }\n}\nfunction consumerPollProducersForChange(node) {\n  assertConsumerNode(node);\n  for (let i = 0; i < node.producerNode.length; i++) {\n    const producer = node.producerNode[i];\n    const seenVersion = node.producerLastReadVersion[i];\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    producerUpdateValueVersion(producer);\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n  var _a;\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (node.liveConsumerNode.length === 0) {\n    (_a = node.watched) == null ? void 0 : _a.call(node.wrapper);\n    for (let i = 0; i < node.producerNode.length; i++) {\n      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n    }\n  }\n  node.liveConsumerIndexOfThis.push(indexOfThis);\n  return node.liveConsumerNode.push(consumer) - 1;\n}\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n  var _a;\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (typeof ngDevMode !== \"undefined\" && ngDevMode && idx >= node.liveConsumerNode.length) {\n    throw new Error(\n      `Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`\n    );\n  }\n  if (node.liveConsumerNode.length === 1) {\n    (_a = node.unwatched) == null ? void 0 : _a.call(node.wrapper);\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  const lastIdx = node.liveConsumerNode.length - 1;\n  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n  node.liveConsumerNode.length--;\n  node.liveConsumerIndexOfThis.length--;\n  if (idx < node.liveConsumerNode.length) {\n    const idxProducer = node.liveConsumerIndexOfThis[idx];\n    const consumer = node.liveConsumerNode[idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis[idxProducer] = idx;\n  }\n}\nfunction consumerIsLive(node) {\n  var _a;\n  return node.consumerIsAlwaysLive || (((_a = node == null ? void 0 : node.liveConsumerNode) == null ? void 0 : _a.length) ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n  node.producerNode ?? (node.producerNode = []);\n  node.producerIndexOfThis ?? (node.producerIndexOfThis = []);\n  node.producerLastReadVersion ?? (node.producerLastReadVersion = []);\n}\nfunction assertProducerNode(node) {\n  node.liveConsumerNode ?? (node.liveConsumerNode = []);\n  node.liveConsumerIndexOfThis ?? (node.liveConsumerIndexOfThis = []);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction computedGet(node) {\n  producerUpdateValueVersion(node);\n  producerAccessed(node);\n  if (node.value === ERRORED) {\n    throw node.error;\n  }\n  return node.value;\n}\nfunction createComputed(computation) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  const computed = () => computedGet(node);\n  computed[SIGNAL] = node;\n  return computed;\n}\nconst UNSET = /* @__PURE__ */ Symbol(\"UNSET\");\nconst COMPUTING = /* @__PURE__ */ Symbol(\"COMPUTING\");\nconst ERRORED = /* @__PURE__ */ Symbol(\"ERRORED\");\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(\"Detected cycle in computations.\");\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      let wasEqual = false;\n      try {\n        newValue = node.computation.call(node.wrapper);\n        const oldOk = oldValue !== UNSET && oldValue !== ERRORED;\n        wasEqual = oldOk && node.equal.call(node.wrapper, oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (wasEqual) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction createSignal(initialValue) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  const getter = () => {\n    producerAccessed(node);\n    return node.value;\n  };\n  getter[SIGNAL] = node;\n  return getter;\n}\nfunction signalGetFn() {\n  producerAccessed(this);\n  return this.value;\n}\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  if (!node.equal.call(node.wrapper, node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: void 0\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n}\n/**\n * @license\n * Copyright 2024 Bloomberg Finance L.P.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst NODE = Symbol(\"node\");\nvar Signal;\n((Signal2) => {\n  var _a, _brand, brand_fn, _b, _brand2, brand_fn2;\n  class State {\n    constructor(initialValue, options = {}) {\n      __privateAdd(this, _brand);\n      __publicField(this, _a);\n      const ref = createSignal(initialValue);\n      const node = ref[SIGNAL];\n      this[NODE] = node;\n      node.wrapper = this;\n      if (options) {\n        const equals = options.equals;\n        if (equals) {\n          node.equal = equals;\n        }\n        node.watched = options[Signal2.subtle.watched];\n        node.unwatched = options[Signal2.subtle.unwatched];\n      }\n    }\n    get() {\n      if (!(0, Signal2.isState)(this))\n        throw new TypeError(\"Wrong receiver type for Signal.State.prototype.get\");\n      return signalGetFn.call(this[NODE]);\n    }\n    set(newValue) {\n      if (!(0, Signal2.isState)(this))\n        throw new TypeError(\"Wrong receiver type for Signal.State.prototype.set\");\n      if (isInNotificationPhase()) {\n        throw new Error(\"Writes to signals not permitted during Watcher callback\");\n      }\n      const ref = this[NODE];\n      signalSetFn(ref, newValue);\n    }\n  }\n  _a = NODE;\n  _brand = new WeakSet();\n  brand_fn = function() {\n  };\n  Signal2.isState = (s) => typeof s === \"object\" && __privateIn(_brand, s);\n  Signal2.State = State;\n  class Computed {\n    // Create a Signal which evaluates to the value returned by the callback.\n    // Callback is called with this signal as the parameter.\n    constructor(computation, options) {\n      __privateAdd(this, _brand2);\n      __publicField(this, _b);\n      const ref = createComputed(computation);\n      const node = ref[SIGNAL];\n      node.consumerAllowSignalWrites = true;\n      this[NODE] = node;\n      node.wrapper = this;\n      if (options) {\n        const equals = options.equals;\n        if (equals) {\n          node.equal = equals;\n        }\n        node.watched = options[Signal2.subtle.watched];\n        node.unwatched = options[Signal2.subtle.unwatched];\n      }\n    }\n    get() {\n      if (!(0, Signal2.isComputed)(this))\n        throw new TypeError(\"Wrong receiver type for Signal.Computed.prototype.get\");\n      return computedGet(this[NODE]);\n    }\n  }\n  _b = NODE;\n  _brand2 = new WeakSet();\n  brand_fn2 = function() {\n  };\n  Signal2.isComputed = (c) => typeof c === \"object\" && __privateIn(_brand2, c);\n  Signal2.Computed = Computed;\n  ((subtle2) => {\n    var _a2, _brand3, brand_fn3, _assertSignals, assertSignals_fn;\n    function untrack(cb) {\n      let output;\n      let prevActiveConsumer = null;\n      try {\n        prevActiveConsumer = setActiveConsumer(null);\n        output = cb();\n      } finally {\n        setActiveConsumer(prevActiveConsumer);\n      }\n      return output;\n    }\n    subtle2.untrack = untrack;\n    function introspectSources(sink) {\n      var _a3;\n      if (!(0, Signal2.isComputed)(sink) && !(0, Signal2.isWatcher)(sink)) {\n        throw new TypeError(\"Called introspectSources without a Computed or Watcher argument\");\n      }\n      return ((_a3 = sink[NODE].producerNode) == null ? void 0 : _a3.map((n) => n.wrapper)) ?? [];\n    }\n    subtle2.introspectSources = introspectSources;\n    function introspectSinks(signal) {\n      var _a3;\n      if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isState)(signal)) {\n        throw new TypeError(\"Called introspectSinks without a Signal argument\");\n      }\n      return ((_a3 = signal[NODE].liveConsumerNode) == null ? void 0 : _a3.map((n) => n.wrapper)) ?? [];\n    }\n    subtle2.introspectSinks = introspectSinks;\n    function hasSinks(signal) {\n      if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isState)(signal)) {\n        throw new TypeError(\"Called hasSinks without a Signal argument\");\n      }\n      const liveConsumerNode = signal[NODE].liveConsumerNode;\n      if (!liveConsumerNode)\n        return false;\n      return liveConsumerNode.length > 0;\n    }\n    subtle2.hasSinks = hasSinks;\n    function hasSources(signal) {\n      if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isWatcher)(signal)) {\n        throw new TypeError(\"Called hasSources without a Computed or Watcher argument\");\n      }\n      const producerNode = signal[NODE].producerNode;\n      if (!producerNode)\n        return false;\n      return producerNode.length > 0;\n    }\n    subtle2.hasSources = hasSources;\n    class Watcher {\n      // When a (recursive) source of Watcher is written to, call this callback,\n      // if it hasn't already been called since the last `watch` call.\n      // No signals may be read or written during the notify.\n      constructor(notify) {\n        __privateAdd(this, _brand3);\n        __privateAdd(this, _assertSignals);\n        __publicField(this, _a2);\n        let node = Object.create(REACTIVE_NODE);\n        node.wrapper = this;\n        node.consumerMarkedDirty = notify;\n        node.consumerIsAlwaysLive = true;\n        node.consumerAllowSignalWrites = false;\n        node.producerNode = [];\n        this[NODE] = node;\n      }\n      // Add these signals to the Watcher's set, and set the watcher to run its\n      // notify callback next time any signal in the set (or one of its dependencies) changes.\n      // Can be called with no arguments just to reset the \"notified\" state, so that\n      // the notify callback will be invoked again.\n      watch(...signals) {\n        if (!(0, Signal2.isWatcher)(this)) {\n          throw new TypeError(\"Called unwatch without Watcher receiver\");\n        }\n        __privateMethod(this, _assertSignals, assertSignals_fn).call(this, signals);\n        const node = this[NODE];\n        node.dirty = false;\n        const prev = setActiveConsumer(node);\n        for (const signal of signals) {\n          producerAccessed(signal[NODE]);\n        }\n        setActiveConsumer(prev);\n      }\n      // Remove these signals from the watched set (e.g., for an effect which is disposed)\n      unwatch(...signals) {\n        if (!(0, Signal2.isWatcher)(this)) {\n          throw new TypeError(\"Called unwatch without Watcher receiver\");\n        }\n        __privateMethod(this, _assertSignals, assertSignals_fn).call(this, signals);\n        const node = this[NODE];\n        assertConsumerNode(node);\n        for (let i = node.producerNode.length - 1; i >= 0; i--) {\n          if (signals.includes(node.producerNode[i].wrapper)) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n            const lastIdx = node.producerNode.length - 1;\n            node.producerNode[i] = node.producerNode[lastIdx];\n            node.producerIndexOfThis[i] = node.producerIndexOfThis[lastIdx];\n            node.producerNode.length--;\n            node.producerIndexOfThis.length--;\n            node.nextProducerIndex--;\n            if (i < node.producerNode.length) {\n              const idxConsumer = node.producerIndexOfThis[i];\n              const producer = node.producerNode[i];\n              assertProducerNode(producer);\n              producer.liveConsumerIndexOfThis[idxConsumer] = i;\n            }\n          }\n        }\n      }\n      // Returns the set of computeds in the Watcher's set which are still yet\n      // to be re-evaluated\n      getPending() {\n        if (!(0, Signal2.isWatcher)(this)) {\n          throw new TypeError(\"Called getPending without Watcher receiver\");\n        }\n        const node = this[NODE];\n        return node.producerNode.filter((n) => n.dirty).map((n) => n.wrapper);\n      }\n    }\n    _a2 = NODE;\n    _brand3 = new WeakSet();\n    brand_fn3 = function() {\n    };\n    _assertSignals = new WeakSet();\n    assertSignals_fn = function(signals) {\n      for (const signal of signals) {\n        if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isState)(signal)) {\n          throw new TypeError(\"Called watch/unwatch without a Computed or State argument\");\n        }\n      }\n    };\n    Signal2.isWatcher = (w) => __privateIn(_brand3, w);\n    subtle2.Watcher = Watcher;\n    function currentComputed() {\n      var _a3;\n      return (_a3 = getActiveConsumer()) == null ? void 0 : _a3.wrapper;\n    }\n    subtle2.currentComputed = currentComputed;\n    subtle2.watched = Symbol(\"watched\");\n    subtle2.unwatched = Symbol(\"unwatched\");\n  })(Signal2.subtle || (Signal2.subtle = {}));\n})(Signal || (Signal = {}));\nexport {\n  Signal\n};\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {PropertyDeclaration, PropertyValueMap, ReactiveElement} from 'lit';\nimport {Signal} from 'signal-polyfill';\nimport {WatchDirective} from './watch.js';\n\ntype ReactiveElementConstructor = abstract new (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: any[]\n) => ReactiveElement;\n\nexport interface SignalWatcher extends ReactiveElement {\n  _updateWatchDirective(d: WatchDirective<unknown>): void;\n  _clearWatchDirective(d: WatchDirective<unknown>): void;\n}\n\ninterface SignalWatcherInterface extends SignalWatcher {}\ninterface SignalWatcherInternal extends SignalWatcher {\n  __forcingUpdate: boolean;\n}\n\nconst signalWatcherBrand: unique symbol = Symbol('SignalWatcherBrand');\n\n// Memory management: We need to ensure that we don't leak memory by creating a\n// reference cycle between an element and its watcher, which then it kept alive\n// by the signals it watches. To avoid this, we break the cycle by using a\n// WeakMap to store the watcher for each element, and a FinalizationRegistry to\n// clean up the watcher when the element is garbage collected.\n\nconst elementFinalizationRegistry = new FinalizationRegistry<{\n  watcher: Signal.subtle.Watcher;\n  signal: Signal.Computed<void>;\n}>(({watcher, signal}) => {\n  watcher.unwatch(signal);\n});\n\nconst elementForWatcher = new WeakMap<\n  Signal.subtle.Watcher,\n  SignalWatcherInternal\n>();\n\n/**\n * Adds the ability for a LitElement or other ReactiveElement class to\n * watch for access to signals during the update lifecycle and trigger a new\n * update when signals values change.\n */\nexport function SignalWatcher<T extends ReactiveElementConstructor>(\n  Base: T\n): T {\n  // Only apply the mixin once\n  if ((Base as typeof SignalWatcher)[signalWatcherBrand] === true) {\n    console.warn(\n      'SignalWatcher should not be applied to the same class more than once.'\n    );\n    return Base;\n  }\n\n  abstract class SignalWatcher extends Base implements SignalWatcherInterface {\n    static [signalWatcherBrand]: true;\n\n    private __watcher?: Signal.subtle.Watcher;\n\n    private __watch() {\n      if (this.__watcher !== undefined) {\n        return;\n      }\n      // We create a fresh computed instead of just re-using the existing one\n      // because of https://github.com/proposal-signals/signal-polyfill/issues/27\n      this.__performUpdateSignal = new Signal.Computed(() => {\n        this.__forceUpdateSignal.get();\n        super.performUpdate();\n      });\n      const watcher = (this.__watcher = new Signal.subtle.Watcher(function (\n        this: Signal.subtle.Watcher\n      ) {\n        // All top-level references in this function body must either be `this`\n        // (the watcher) or a module global to prevent this closure from keeping\n        // the enclosing scopes alive, which would keep the element alive. So\n        // The only two references are `this` and `elementForWatcher`.\n        const el = elementForWatcher.get(this);\n        if (el === undefined) {\n          // The element was garbage collected, so we can stop watching.\n          return;\n        }\n        if (el.__forcingUpdate === false) {\n          el.requestUpdate();\n        }\n        this.watch();\n      }));\n      elementForWatcher.set(watcher, this as unknown as SignalWatcherInternal);\n      elementFinalizationRegistry.register(this, {\n        watcher,\n        signal: this.__performUpdateSignal,\n      });\n      watcher.watch(this.__performUpdateSignal);\n    }\n\n    private __unwatch() {\n      if (this.__watcher === undefined) {\n        return;\n      }\n      this.__watcher.unwatch(this.__performUpdateSignal!);\n      this.__performUpdateSignal = undefined;\n      this.__watcher = undefined;\n    }\n\n    /**\n     * Used to force an uncached read of the __performUpdateSignal when we need\n     * to read the current value during an update.\n     *\n     * If https://github.com/tc39/proposal-signals/issues/151 is resolved, we\n     * won't need this.\n     */\n    private __forceUpdateSignal = new Signal.State(0);\n\n    /*\n     * This field is used within the watcher to determine if the watcher\n     * notification was triggered by our performUpdate() override. Because we\n     * force a fresh read of the __performUpdateSignal by changing value of the\n     * __forceUpdate signal, the watcher will be notified. But we're already\n     * performing an update, so we don't want to enqueue another one.\n     */\n    // @ts-expect-error This field is accessed in a watcher function with a\n    // different `this` context, so TypeScript can't see the access.\n    private __forcingUpdate = false;\n\n    /**\n     * A computed signal that wraps performUpdate() so that all signals that are\n     * accessed during the update lifecycle are tracked.\n     *\n     * __forceUpdateSignal is used to force an uncached read of this signal\n     * because updates may easily depend on non-signal values, so we must always\n     * re-run it.\n     */\n    private __performUpdateSignal?: Signal.Computed<void>;\n\n    /**\n     * Whether or not the next update should perform a full render, or if only\n     * pending watches should be committed.\n     *\n     * If requestUpdate() was called only because of watch() directive updates,\n     * then we can just commit those directives without a full render. If\n     * requestUpdate() was called for any other reason, we need to perform a\n     * full render, and don't need to separately commit the watch() directives.\n     *\n     * This is set to `true` initially, and whenever requestUpdate() is called\n     * outside of a watch() directive update. It is set to `false` when\n     * update() is called, so that a requestUpdate() is required to do another\n     * full render.\n     */\n    private __doFullRender = true;\n\n    /**\n     * Set of watch directives that have been updated since the last update.\n     * These will be committed in update() to ensure that the latest value is\n     * rendered and that all updates are batched.\n     */\n    private __pendingWatches = new Set<WatchDirective<unknown>>();\n\n    protected override performUpdate() {\n      if (!this.isUpdatePending) {\n        // super.performUpdate() performs this check, so we bail early so that\n        // we don't read the __performUpdateSignal when it's not going to access\n        // any signals. This keeps the last signals read as the sources so that\n        // we'll get notified of changes to them.\n        return;\n      }\n      // Always enable watching before an update, even if disconnected, so that\n      // we can track signals that are accessed during the update.\n      this.__watch();\n      // Force an uncached read of __performUpdateSignal\n      this.__forcingUpdate = true;\n      this.__forceUpdateSignal.set(this.__forceUpdateSignal.get() + 1);\n      this.__forcingUpdate = false;\n      // Always read from the signal to ensure that it's tracked\n      this.__performUpdateSignal!.get();\n    }\n\n    protected override update(\n      changedProperties: PropertyValueMap<this> | Map<PropertyKey, unknown>\n    ): void {\n      // We need a try block because both super.update() and\n      // WatchDirective.commit() can throw, and we need to ensure that post-\n      // update cleanup happens.\n      try {\n        if (this.__doFullRender) {\n          // Force future updates to not perform full renders by default.\n          this.__doFullRender = false;\n          super.update(changedProperties);\n        } else {\n          // For a partial render, just commit the pending watches.\n          // TODO (justinfagnani): Should we access each signal in a separate\n          // try block?\n          this.__pendingWatches.forEach((d) => d.commit());\n        }\n      } finally {\n        // If we didn't call super.update(), we need to set this to false\n        this.isUpdatePending = false;\n        this.__pendingWatches.clear();\n      }\n    }\n\n    override requestUpdate(\n      name?: PropertyKey | undefined,\n      oldValue?: unknown,\n      options?: PropertyDeclaration<unknown, unknown> | undefined\n    ): void {\n      this.__doFullRender = true;\n      super.requestUpdate(name, oldValue, options);\n    }\n\n    override connectedCallback(): void {\n      super.connectedCallback();\n      // Because we might have missed some signal updates while disconnected,\n      // we force a full render on the next update.\n      this.requestUpdate();\n    }\n\n    override disconnectedCallback(): void {\n      super.disconnectedCallback();\n      // Clean up the watcher earlier than the FinalizationRegistry will, to\n      // avoid memory pressure from signals holding references to the element\n      // via the watcher.\n      //\n      // This means that while disconnected, regular reactive property updates\n      // will trigger a re-render, but signal updates will not. To ensure that\n      // current signal usage is still correctly tracked, we re-enable watching\n      // in performUpdate() even while disconnected. From that point on, a\n      // disconnected element will be retained by the signals it accesses during\n      // the update lifecycle.\n      //\n      // We use queueMicrotask() to ensure that this cleanup does not happen\n      // because of moves in the DOM within the same task, such as removing an\n      // element with .remove() and then adding it back later with .append()\n      // in the same task. For example, repeat() works this way.\n      queueMicrotask(() => {\n        if (this.isConnected === false) {\n          this.__unwatch();\n        }\n      });\n    }\n\n    /**\n     * Enqueues an update caused by a signal change observed by a watch()\n     * directive.\n     *\n     * Note: the method is not part of the public API and is subject to change.\n     * In particular, it may be removed if the watch() directive is updated to\n     * work with standalone lit-html templates.\n     *\n     * @internal\n     */\n    _updateWatchDirective(d: WatchDirective<unknown>): void {\n      this.__pendingWatches.add(d);\n      // requestUpdate() will set __doFullRender to true, so remember the\n      // current value and restore it after calling requestUpdate().\n      const shouldRender = this.__doFullRender;\n      this.requestUpdate();\n      this.__doFullRender = shouldRender;\n    }\n\n    /**\n     * Clears a watch() directive from the set of pending watches.\n     *\n     * Note: the method is not part of the public API and is subject to change.\n     *\n     * @internal\n     */\n    _clearWatchDirective(d: WatchDirective<unknown>): void {\n      this.__pendingWatches.delete(d);\n    }\n  }\n  return SignalWatcher;\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {DirectiveResult, Part, directive} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {Signal} from 'signal-polyfill';\nimport {SignalWatcher} from './signal-watcher.js';\n\nexport class WatchDirective<T> extends AsyncDirective {\n  private __host?: SignalWatcher;\n\n  private __signal?: Signal.State<T> | Signal.Computed<T>;\n\n  private __watcher?: Signal.subtle.Watcher;\n\n  // We have to wrap the signal in a computed to work around a bug in the\n  // signal-polyfill: https://github.com/proposal-signals/signal-polyfill/issues/27\n  private __computed?: Signal.Computed<T | undefined>;\n\n  private __watch() {\n    if (this.__watcher !== undefined) {\n      return;\n    }\n    this.__computed = new Signal.Computed(() => {\n      return this.__signal?.get();\n    });\n    const watcher = (this.__watcher = new Signal.subtle.Watcher(() => {\n      // TODO: If we're not running inside a SignalWatcher, we can commit to\n      // the DOM independently.\n      this.__host?._updateWatchDirective(this as WatchDirective<unknown>);\n      watcher.watch();\n    }));\n    watcher.watch(this.__computed);\n  }\n\n  private __unwatch() {\n    if (this.__watcher !== undefined) {\n      this.__watcher.unwatch(this.__computed!);\n      this.__computed = undefined;\n      this.__watcher = undefined;\n      this.__host?._clearWatchDirective(this as WatchDirective<unknown>);\n    }\n  }\n\n  commit() {\n    this.setValue(Signal.subtle.untrack(() => this.__computed?.get()));\n  }\n\n  render(signal: Signal.State<T> | Signal.Computed<T>): T {\n    // This would only be called if render is called directly, like in SSR.\n    return Signal.subtle.untrack(() => signal.get());\n  }\n\n  override update(\n    part: Part,\n    [signal]: [signal: Signal.State<T> | Signal.Computed<T>]\n  ) {\n    this.__host ??= part.options?.host as SignalWatcher;\n    if (signal !== this.__signal && this.__signal !== undefined) {\n      // Unwatch the old signal\n      this.__unwatch();\n    }\n    this.__signal = signal;\n    this.__watch();\n\n    // We use untrack() so that the signal access is not tracked by the watcher\n    // created by SignalWatcher. This means that an can use both SignalWatcher\n    // and watch() and a signal update won't trigger a full element update if\n    // it's only passed to watch() and not otherwise accessed by the element.\n    return Signal.subtle.untrack(() => this.__computed!.get());\n  }\n\n  protected override disconnected(): void {\n    this.__unwatch();\n  }\n\n  protected override reconnected(): void {\n    this.__watch();\n  }\n}\n\nexport type WatchDirectiveFunction = <T>(\n  signal: Signal.State<T> | Signal.Computed<T>\n) => DirectiveResult<typeof WatchDirective<T>>;\n\n/**\n * Renders a signal and subscribes to it, updating the part when the signal\n * changes.\n *\n * watch() can only be used in a reactive element that applies the\n * SignalWatcher mixin.\n */\nexport const watch = directive(WatchDirective) as WatchDirectiveFunction;\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {\n  html as coreHtml,\n  svg as coreSvg,\n  type TemplateResult,\n} from 'lit/html.js';\n\nimport {watch} from './watch.js';\nimport {Signal} from 'signal-polyfill';\n\n/**\n * Wraps a lit-html template tag function (`html` or `svg`) to add support for\n * automatically wrapping Signal instances in the `watch()` directive.\n */\nexport const withWatch =\n  (coreTag: typeof coreHtml | typeof coreSvg) =>\n  (strings: TemplateStringsArray, ...values: unknown[]): TemplateResult => {\n    // TODO (justinfagnani): use an alternative to instanceof when\n    // one is available. See https://github.com/preactjs/signals/issues/402\n    return coreTag(\n      strings,\n      ...values.map((v) =>\n        v instanceof Signal.State || v instanceof Signal.Computed ? watch(v) : v\n      )\n    );\n  };\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n *\n * Includes signal watching support from `withWatch()`.\n */\nexport const html = withWatch(coreHtml);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n *\n * Includes signal watching support from `withWatch()`.\n */\nexport const svg = withWatch(coreSvg);\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Signal} from 'signal-polyfill';\n\nexport * from 'signal-polyfill';\nexport * from './lib/signal-watcher.js';\nexport * from './lib/watch.js';\nexport * from './lib/html-tag.js';\n\nexport const State = Signal.State;\nexport const Computed = Signal.Computed;\n\nexport const signal = <T>(value: T, options?: Signal.Options<T>) =>\n  new Signal.State(value, options);\nexport const computed = <T>(callback: () => T, options?: Signal.Options<T>) =>\n  new Signal.Computed<T>(callback, options);\n"],
  "mappings": "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",
  "names": ["computed", "State", "Computed", "signal", "signal", "SignalWatcher", "signal", "html", "svg"]
}
