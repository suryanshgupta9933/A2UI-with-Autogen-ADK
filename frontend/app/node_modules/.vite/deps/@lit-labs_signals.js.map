{
  "version": 3,
  "sources": ["../../../../packages/lit/node_modules/@lit-labs/signals/src/lib/signal-watcher.ts", "../../../../packages/lit/node_modules/@lit-labs/signals/src/lib/watch.ts", "../../../../packages/lit/node_modules/@lit-labs/signals/src/lib/html-tag.ts", "../../../../packages/lit/node_modules/@lit-labs/signals/src/index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {PropertyDeclaration, PropertyValueMap, ReactiveElement} from 'lit';\nimport {Signal} from 'signal-polyfill';\nimport {WatchDirective} from './watch.js';\n\ntype ReactiveElementConstructor = abstract new (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: any[]\n) => ReactiveElement;\n\nexport interface SignalWatcher extends ReactiveElement {\n  _updateWatchDirective(d: WatchDirective<unknown>): void;\n  _clearWatchDirective(d: WatchDirective<unknown>): void;\n}\n\ninterface SignalWatcherInterface extends SignalWatcher {}\ninterface SignalWatcherInternal extends SignalWatcher {\n  __forcingUpdate: boolean;\n}\n\nconst signalWatcherBrand: unique symbol = Symbol('SignalWatcherBrand');\n\n// Memory management: We need to ensure that we don't leak memory by creating a\n// reference cycle between an element and its watcher, which then it kept alive\n// by the signals it watches. To avoid this, we break the cycle by using a\n// WeakMap to store the watcher for each element, and a FinalizationRegistry to\n// clean up the watcher when the element is garbage collected.\n\nconst elementFinalizationRegistry = new FinalizationRegistry<{\n  watcher: Signal.subtle.Watcher;\n  signal: Signal.Computed<void>;\n}>(({watcher, signal}) => {\n  watcher.unwatch(signal);\n});\n\nconst elementForWatcher = new WeakMap<\n  Signal.subtle.Watcher,\n  SignalWatcherInternal\n>();\n\n/**\n * Adds the ability for a LitElement or other ReactiveElement class to\n * watch for access to signals during the update lifecycle and trigger a new\n * update when signals values change.\n */\nexport function SignalWatcher<T extends ReactiveElementConstructor>(\n  Base: T\n): T {\n  // Only apply the mixin once\n  if ((Base as typeof SignalWatcher)[signalWatcherBrand] === true) {\n    console.warn(\n      'SignalWatcher should not be applied to the same class more than once.'\n    );\n    return Base;\n  }\n\n  abstract class SignalWatcher extends Base implements SignalWatcherInterface {\n    static [signalWatcherBrand]: true;\n\n    private __watcher?: Signal.subtle.Watcher;\n\n    private __watch() {\n      if (this.__watcher !== undefined) {\n        return;\n      }\n      // We create a fresh computed instead of just re-using the existing one\n      // because of https://github.com/proposal-signals/signal-polyfill/issues/27\n      this.__performUpdateSignal = new Signal.Computed(() => {\n        this.__forceUpdateSignal.get();\n        super.performUpdate();\n      });\n      const watcher = (this.__watcher = new Signal.subtle.Watcher(function (\n        this: Signal.subtle.Watcher\n      ) {\n        // All top-level references in this function body must either be `this`\n        // (the watcher) or a module global to prevent this closure from keeping\n        // the enclosing scopes alive, which would keep the element alive. So\n        // The only two references are `this` and `elementForWatcher`.\n        const el = elementForWatcher.get(this);\n        if (el === undefined) {\n          // The element was garbage collected, so we can stop watching.\n          return;\n        }\n        if (el.__forcingUpdate === false) {\n          el.requestUpdate();\n        }\n        this.watch();\n      }));\n      elementForWatcher.set(watcher, this as unknown as SignalWatcherInternal);\n      elementFinalizationRegistry.register(this, {\n        watcher,\n        signal: this.__performUpdateSignal,\n      });\n      watcher.watch(this.__performUpdateSignal);\n    }\n\n    private __unwatch() {\n      if (this.__watcher === undefined) {\n        return;\n      }\n      this.__watcher.unwatch(this.__performUpdateSignal!);\n      this.__performUpdateSignal = undefined;\n      this.__watcher = undefined;\n    }\n\n    /**\n     * Used to force an uncached read of the __performUpdateSignal when we need\n     * to read the current value during an update.\n     *\n     * If https://github.com/tc39/proposal-signals/issues/151 is resolved, we\n     * won't need this.\n     */\n    private __forceUpdateSignal = new Signal.State(0);\n\n    /*\n     * This field is used within the watcher to determine if the watcher\n     * notification was triggered by our performUpdate() override. Because we\n     * force a fresh read of the __performUpdateSignal by changing value of the\n     * __forceUpdate signal, the watcher will be notified. But we're already\n     * performing an update, so we don't want to enqueue another one.\n     */\n    // @ts-expect-error This field is accessed in a watcher function with a\n    // different `this` context, so TypeScript can't see the access.\n    private __forcingUpdate = false;\n\n    /**\n     * A computed signal that wraps performUpdate() so that all signals that are\n     * accessed during the update lifecycle are tracked.\n     *\n     * __forceUpdateSignal is used to force an uncached read of this signal\n     * because updates may easily depend on non-signal values, so we must always\n     * re-run it.\n     */\n    private __performUpdateSignal?: Signal.Computed<void>;\n\n    /**\n     * Whether or not the next update should perform a full render, or if only\n     * pending watches should be committed.\n     *\n     * If requestUpdate() was called only because of watch() directive updates,\n     * then we can just commit those directives without a full render. If\n     * requestUpdate() was called for any other reason, we need to perform a\n     * full render, and don't need to separately commit the watch() directives.\n     *\n     * This is set to `true` initially, and whenever requestUpdate() is called\n     * outside of a watch() directive update. It is set to `false` when\n     * update() is called, so that a requestUpdate() is required to do another\n     * full render.\n     */\n    private __doFullRender = true;\n\n    /**\n     * Set of watch directives that have been updated since the last update.\n     * These will be committed in update() to ensure that the latest value is\n     * rendered and that all updates are batched.\n     */\n    private __pendingWatches = new Set<WatchDirective<unknown>>();\n\n    protected override performUpdate() {\n      if (!this.isUpdatePending) {\n        // super.performUpdate() performs this check, so we bail early so that\n        // we don't read the __performUpdateSignal when it's not going to access\n        // any signals. This keeps the last signals read as the sources so that\n        // we'll get notified of changes to them.\n        return;\n      }\n      // Always enable watching before an update, even if disconnected, so that\n      // we can track signals that are accessed during the update.\n      this.__watch();\n      // Force an uncached read of __performUpdateSignal\n      this.__forcingUpdate = true;\n      this.__forceUpdateSignal.set(this.__forceUpdateSignal.get() + 1);\n      this.__forcingUpdate = false;\n      // Always read from the signal to ensure that it's tracked\n      this.__performUpdateSignal!.get();\n    }\n\n    protected override update(\n      changedProperties: PropertyValueMap<this> | Map<PropertyKey, unknown>\n    ): void {\n      // We need a try block because both super.update() and\n      // WatchDirective.commit() can throw, and we need to ensure that post-\n      // update cleanup happens.\n      try {\n        if (this.__doFullRender) {\n          // Force future updates to not perform full renders by default.\n          this.__doFullRender = false;\n          super.update(changedProperties);\n        } else {\n          // For a partial render, just commit the pending watches.\n          // TODO (justinfagnani): Should we access each signal in a separate\n          // try block?\n          this.__pendingWatches.forEach((d) => d.commit());\n        }\n      } finally {\n        // If we didn't call super.update(), we need to set this to false\n        this.isUpdatePending = false;\n        this.__pendingWatches.clear();\n      }\n    }\n\n    override requestUpdate(\n      name?: PropertyKey | undefined,\n      oldValue?: unknown,\n      options?: PropertyDeclaration<unknown, unknown> | undefined\n    ): void {\n      this.__doFullRender = true;\n      super.requestUpdate(name, oldValue, options);\n    }\n\n    override connectedCallback(): void {\n      super.connectedCallback();\n      // Because we might have missed some signal updates while disconnected,\n      // we force a full render on the next update.\n      this.requestUpdate();\n    }\n\n    override disconnectedCallback(): void {\n      super.disconnectedCallback();\n      // Clean up the watcher earlier than the FinalizationRegistry will, to\n      // avoid memory pressure from signals holding references to the element\n      // via the watcher.\n      //\n      // This means that while disconnected, regular reactive property updates\n      // will trigger a re-render, but signal updates will not. To ensure that\n      // current signal usage is still correctly tracked, we re-enable watching\n      // in performUpdate() even while disconnected. From that point on, a\n      // disconnected element will be retained by the signals it accesses during\n      // the update lifecycle.\n      //\n      // We use queueMicrotask() to ensure that this cleanup does not happen\n      // because of moves in the DOM within the same task, such as removing an\n      // element with .remove() and then adding it back later with .append()\n      // in the same task. For example, repeat() works this way.\n      queueMicrotask(() => {\n        if (this.isConnected === false) {\n          this.__unwatch();\n        }\n      });\n    }\n\n    /**\n     * Enqueues an update caused by a signal change observed by a watch()\n     * directive.\n     *\n     * Note: the method is not part of the public API and is subject to change.\n     * In particular, it may be removed if the watch() directive is updated to\n     * work with standalone lit-html templates.\n     *\n     * @internal\n     */\n    _updateWatchDirective(d: WatchDirective<unknown>): void {\n      this.__pendingWatches.add(d);\n      // requestUpdate() will set __doFullRender to true, so remember the\n      // current value and restore it after calling requestUpdate().\n      const shouldRender = this.__doFullRender;\n      this.requestUpdate();\n      this.__doFullRender = shouldRender;\n    }\n\n    /**\n     * Clears a watch() directive from the set of pending watches.\n     *\n     * Note: the method is not part of the public API and is subject to change.\n     *\n     * @internal\n     */\n    _clearWatchDirective(d: WatchDirective<unknown>): void {\n      this.__pendingWatches.delete(d);\n    }\n  }\n  return SignalWatcher;\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {DirectiveResult, Part, directive} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {Signal} from 'signal-polyfill';\nimport {SignalWatcher} from './signal-watcher.js';\n\nexport class WatchDirective<T> extends AsyncDirective {\n  private __host?: SignalWatcher;\n\n  private __signal?: Signal.State<T> | Signal.Computed<T>;\n\n  private __watcher?: Signal.subtle.Watcher;\n\n  // We have to wrap the signal in a computed to work around a bug in the\n  // signal-polyfill: https://github.com/proposal-signals/signal-polyfill/issues/27\n  private __computed?: Signal.Computed<T | undefined>;\n\n  private __watch() {\n    if (this.__watcher !== undefined) {\n      return;\n    }\n    this.__computed = new Signal.Computed(() => {\n      return this.__signal?.get();\n    });\n    const watcher = (this.__watcher = new Signal.subtle.Watcher(() => {\n      // TODO: If we're not running inside a SignalWatcher, we can commit to\n      // the DOM independently.\n      this.__host?._updateWatchDirective(this as WatchDirective<unknown>);\n      watcher.watch();\n    }));\n    watcher.watch(this.__computed);\n  }\n\n  private __unwatch() {\n    if (this.__watcher !== undefined) {\n      this.__watcher.unwatch(this.__computed!);\n      this.__computed = undefined;\n      this.__watcher = undefined;\n      this.__host?._clearWatchDirective(this as WatchDirective<unknown>);\n    }\n  }\n\n  commit() {\n    this.setValue(Signal.subtle.untrack(() => this.__computed?.get()));\n  }\n\n  render(signal: Signal.State<T> | Signal.Computed<T>): T {\n    // This would only be called if render is called directly, like in SSR.\n    return Signal.subtle.untrack(() => signal.get());\n  }\n\n  override update(\n    part: Part,\n    [signal]: [signal: Signal.State<T> | Signal.Computed<T>]\n  ) {\n    this.__host ??= part.options?.host as SignalWatcher;\n    if (signal !== this.__signal && this.__signal !== undefined) {\n      // Unwatch the old signal\n      this.__unwatch();\n    }\n    this.__signal = signal;\n    this.__watch();\n\n    // We use untrack() so that the signal access is not tracked by the watcher\n    // created by SignalWatcher. This means that an can use both SignalWatcher\n    // and watch() and a signal update won't trigger a full element update if\n    // it's only passed to watch() and not otherwise accessed by the element.\n    return Signal.subtle.untrack(() => this.__computed!.get());\n  }\n\n  protected override disconnected(): void {\n    this.__unwatch();\n  }\n\n  protected override reconnected(): void {\n    this.__watch();\n  }\n}\n\nexport type WatchDirectiveFunction = <T>(\n  signal: Signal.State<T> | Signal.Computed<T>\n) => DirectiveResult<typeof WatchDirective<T>>;\n\n/**\n * Renders a signal and subscribes to it, updating the part when the signal\n * changes.\n *\n * watch() can only be used in a reactive element that applies the\n * SignalWatcher mixin.\n */\nexport const watch = directive(WatchDirective) as WatchDirectiveFunction;\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {\n  html as coreHtml,\n  svg as coreSvg,\n  type TemplateResult,\n} from 'lit/html.js';\n\nimport {watch} from './watch.js';\nimport {Signal} from 'signal-polyfill';\n\n/**\n * Wraps a lit-html template tag function (`html` or `svg`) to add support for\n * automatically wrapping Signal instances in the `watch()` directive.\n */\nexport const withWatch =\n  (coreTag: typeof coreHtml | typeof coreSvg) =>\n  (strings: TemplateStringsArray, ...values: unknown[]): TemplateResult => {\n    // TODO (justinfagnani): use an alternative to instanceof when\n    // one is available. See https://github.com/preactjs/signals/issues/402\n    return coreTag(\n      strings,\n      ...values.map((v) =>\n        v instanceof Signal.State || v instanceof Signal.Computed ? watch(v) : v\n      )\n    );\n  };\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n *\n * Includes signal watching support from `withWatch()`.\n */\nexport const html = withWatch(coreHtml);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n *\n * Includes signal watching support from `withWatch()`.\n */\nexport const svg = withWatch(coreSvg);\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Signal} from 'signal-polyfill';\n\nexport * from 'signal-polyfill';\nexport * from './lib/signal-watcher.js';\nexport * from './lib/watch.js';\nexport * from './lib/html-tag.js';\n\nexport const State = Signal.State;\nexport const Computed = Signal.Computed;\n\nexport const signal = <T>(value: T, options?: Signal.Options<T>) =>\n  new Signal.State(value, options);\nexport const computed = <T>(callback: () => T, options?: Signal.Options<T>) =>\n  new Signal.Computed<T>(callback, options);\n"],
  "mappings": "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",
  "names": ["signal", "SignalWatcher", "signal", "html", "svg"]
}
