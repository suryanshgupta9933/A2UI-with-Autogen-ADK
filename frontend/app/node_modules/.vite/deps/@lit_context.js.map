{
  "version": 3,
  "sources": ["../../../../packages/lit/node_modules/@lit/context/src/lib/context-request-event.ts", "../../../../packages/lit/node_modules/@lit/context/src/lib/create-context.ts", "../../../../packages/lit/node_modules/@lit/context/src/lib/controllers/context-consumer.ts", "../../../../packages/lit/node_modules/@lit/context/src/lib/value-notifier.ts", "../../../../packages/lit/node_modules/@lit/context/src/lib/controllers/context-provider.ts", "../../../../packages/lit/node_modules/@lit/context/src/lib/context-root.ts", "../../../../packages/lit/node_modules/@lit/context/src/lib/decorators/provide.ts", "../../../../packages/lit/node_modules/@lit/context/src/lib/decorators/consume.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextType, Context} from './create-context.js';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-request' event can be emitted by any element which desires\n     * a context value to be injected by an external provider.\n     */\n    'context-request': ContextRequestEvent<Context<unknown, unknown>>;\n  }\n}\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\nexport type ContextCallback<ValueType> = (\n  value: ValueType,\n  unsubscribe?: () => void\n) => void;\n\n/**\n * Interface definition for a ContextRequest\n */\nexport interface ContextRequest<C extends Context<unknown, unknown>> {\n  readonly context: C;\n  readonly contextTarget: Element;\n  readonly callback: ContextCallback<ContextType<C>>;\n  readonly subscribe?: boolean;\n}\n\n/**\n * An event fired by a context requester to signal it desires a specified context with the given key.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * method to the callback which consumers can invoke to indicate they no longer wish to receive these updates.\n *\n * If no `subscribe` value is present in the event, then the provider can assume that this is a 'one time'\n * request for the context and can therefore not track the consumer.\n */\nexport class ContextRequestEvent<C extends Context<unknown, unknown>>\n  extends Event\n  implements ContextRequest<C>\n{\n  readonly context: C;\n  readonly contextTarget: Element;\n  readonly callback: ContextCallback<ContextType<C>>;\n  readonly subscribe?: boolean;\n\n  /**\n   *\n   * @param context the context key to request\n   * @param contextTarget the original context target of the requester\n   * @param callback the callback that should be invoked when the context with the specified key is available\n   * @param subscribe when, true indicates we want to subscribe to future updates\n   */\n  constructor(\n    context: C,\n    contextTarget: Element,\n    callback: ContextCallback<ContextType<C>>,\n    subscribe?: boolean\n  ) {\n    super('context-request', {bubbles: true, composed: true});\n    this.context = context;\n    this.contextTarget = contextTarget;\n    this.callback = callback;\n    this.subscribe = subscribe ?? false;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * The Context type defines a type brand to associate a key value with the context value type\n */\nexport type Context<KeyType, ValueType> = KeyType & {__context__: ValueType};\n\n/**\n * @deprecated use Context instead\n */\nexport type ContextKey<KeyType, ValueType> = Context<KeyType, ValueType>;\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\nexport type ContextType<Key extends Context<unknown, unknown>> =\n  Key extends Context<unknown, infer ValueType> ? ValueType : never;\n\n/**\n * Creates a typed Context.\n *\n * Contexts are compared with strict equality.\n *\n * If you want two separate `createContext()` calls to referer to the same\n * context, then use a key that will by equal under strict equality like a\n * string for `Symbol.for()`:\n *\n * ```ts\n * // true\n * createContext('my-context') === createContext('my-context')\n * // true\n * createContext(Symbol.for('my-context')) === createContext(Symbol.for('my-context'))\n * ```\n *\n * If you want a context to be unique so that it's guaranteed to not collide\n * with other contexts, use a key that's unique under strict equality, like\n * a `Symbol()` or object.:\n *\n * ```\n * // false\n * createContext({}) === createContext({})\n * // false\n * createContext(Symbol('my-context')) === createContext(Symbol('my-context'))\n * ```\n *\n * @param key a context key value\n * @template ValueType the type of value that can be provided by this context.\n * @returns the context key value cast to `Context<K, ValueType>`\n */\nexport function createContext<ValueType, K = unknown>(key: K) {\n  return key as Context<K, ValueType>;\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  ContextCallback,\n  ContextRequestEvent,\n} from '../context-request-event.js';\nimport type {Context, ContextType} from '../create-context.js';\nimport type {\n  ReactiveController,\n  ReactiveControllerHost,\n} from '@lit/reactive-element';\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  callback?: (value: ContextType<C>, dispose?: () => void) => void;\n  subscribe?: boolean;\n}\n\n/**\n * A ReactiveController which adds context consuming behavior to a custom\n * element by dispatching `context-request` events.\n *\n * When the host element is connected to the document it will emit a\n * `context-request` event with its context key. When the context request\n * is satisfied the controller will invoke the callback, if present, and\n * trigger a host update so it can respond to the new value.\n *\n * It will also call the dispose method given by the provider when the\n * host element is disconnected.\n */\nexport class ContextConsumer<\n  C extends Context<unknown, unknown>,\n  HostElement extends ReactiveControllerHost & HTMLElement,\n> implements ReactiveController\n{\n  protected host: HostElement;\n  private context: C;\n  private callback?: (value: ContextType<C>, dispose?: () => void) => void;\n  private subscribe = false;\n\n  private provided = false;\n\n  value?: ContextType<C> = undefined;\n\n  constructor(host: HostElement, options: Options<C>);\n  /** @deprecated Use new ContextConsumer(host, options) */\n  constructor(\n    host: HostElement,\n    context: C,\n    callback?: (value: ContextType<C>, dispose?: () => void) => void,\n    subscribe?: boolean\n  );\n  constructor(\n    host: HostElement,\n    contextOrOptions: C | Options<C>,\n    callback?: (value: ContextType<C>, dispose?: () => void) => void,\n    subscribe?: boolean\n  ) {\n    this.host = host;\n    // This is a potentially fragile duck-type. It means a context object can't\n    // have a property name context and be used in positional argument form.\n    if ((contextOrOptions as Options<C>).context !== undefined) {\n      const options = contextOrOptions as Options<C>;\n      this.context = options.context;\n      this.callback = options.callback;\n      this.subscribe = options.subscribe ?? false;\n    } else {\n      this.context = contextOrOptions as C;\n      this.callback = callback;\n      this.subscribe = subscribe ?? false;\n    }\n    this.host.addController(this);\n  }\n\n  private unsubscribe?: () => void;\n\n  hostConnected(): void {\n    this.dispatchRequest();\n  }\n\n  hostDisconnected(): void {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = undefined;\n    }\n  }\n\n  private dispatchRequest() {\n    this.host.dispatchEvent(\n      new ContextRequestEvent(\n        this.context,\n        this.host,\n        this._callback,\n        this.subscribe\n      )\n    );\n  }\n\n  // This function must have stable identity to properly dedupe in ContextRoot\n  // if this element connects multiple times.\n  private _callback: ContextCallback<ContextType<C>> = (value, unsubscribe) => {\n    // some providers will pass an unsubscribe function indicating they may provide future values\n    if (this.unsubscribe) {\n      // if the unsubscribe function changes this implies we have changed provider\n      if (this.unsubscribe !== unsubscribe) {\n        // cleanup the old provider\n        this.provided = false;\n        this.unsubscribe();\n      }\n      // if we don't support subscription, immediately unsubscribe\n      if (!this.subscribe) {\n        this.unsubscribe();\n      }\n    }\n\n    // store the value so that it can be retrieved from the controller\n    this.value = value;\n    // schedule an update in case this value is used in a template\n    this.host.requestUpdate();\n\n    // only invoke callback if we are either expecting updates or have not yet\n    // been provided a value\n    if (!this.provided || this.subscribe) {\n      this.provided = true;\n      if (this.callback) {\n        this.callback(value, unsubscribe);\n      }\n    }\n\n    this.unsubscribe = unsubscribe;\n  };\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextCallback} from './context-request-event.js';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\ninterface CallbackInfo {\n  disposer: Disposer;\n  consumerHost: Element;\n}\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport class ValueNotifier<T> {\n  protected readonly subscriptions = new Map<\n    ContextCallback<T>,\n    CallbackInfo\n  >();\n  private _value!: T;\n  get value(): T {\n    return this._value;\n  }\n  set value(v: T) {\n    this.setValue(v);\n  }\n\n  setValue(v: T, force = false) {\n    const update = force || !Object.is(v, this._value);\n    this._value = v;\n    if (update) {\n      this.updateObservers();\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  updateObservers = (): void => {\n    for (const [callback, {disposer}] of this.subscriptions) {\n      callback(this._value, disposer);\n    }\n  };\n\n  addCallback(\n    callback: ContextCallback<T>,\n    consumerHost: Element,\n    subscribe?: boolean\n  ): void {\n    if (!subscribe) {\n      // just call the callback once and we're done\n      callback(this.value);\n      return;\n    }\n    if (!this.subscriptions.has(callback)) {\n      this.subscriptions.set(callback, {\n        disposer: () => {\n          this.subscriptions.delete(callback);\n        },\n        consumerHost,\n      });\n    }\n    const {disposer} = this.subscriptions.get(callback)!;\n    callback(this.value, disposer);\n  }\n\n  clearCallbacks(): void {\n    this.subscriptions.clear();\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextRequestEvent} from '../context-request-event.js';\nimport {ValueNotifier} from '../value-notifier.js';\nimport type {Context, ContextType} from '../create-context.js';\nimport type {\n  ReactiveController,\n  ReactiveControllerHost,\n} from '@lit/reactive-element';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-provider' event can be emitted by any element which hosts\n     * a context provider to indicate it is available for use.\n     */\n    'context-provider': ContextProviderEvent<Context<unknown, unknown>>;\n  }\n}\n\nexport class ContextProviderEvent<\n  C extends Context<unknown, unknown>,\n> extends Event {\n  readonly context: C;\n  readonly contextTarget: Element;\n\n  /**\n   *\n   * @param context the context which this provider can provide\n   * @param contextTarget the original context target of the provider\n   */\n  constructor(context: C, contextTarget: Element) {\n    super('context-provider', {bubbles: true, composed: true});\n    this.context = context;\n    this.contextTarget = contextTarget;\n  }\n}\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  initialValue?: ContextType<C>;\n}\n\ntype ReactiveElementHost = Partial<ReactiveControllerHost> & HTMLElement;\n\n/**\n * A ReactiveController which adds context provider behavior to a\n * custom element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n *\n * The controller may also be attached to any HTML element in which case it's\n * up to the user to call hostConnected() when attached to the DOM. This is\n * done automatically for any custom elements implementing\n * ReactiveControllerHost.\n */\nexport class ContextProvider<\n    T extends Context<unknown, unknown>,\n    HostElement extends ReactiveElementHost = ReactiveElementHost,\n  >\n  extends ValueNotifier<ContextType<T>>\n  implements ReactiveController\n{\n  protected readonly host: HostElement;\n  private readonly context: T;\n\n  constructor(host: HostElement, options: Options<T>);\n  /** @deprecated Use new ContextProvider(host, options) */\n  constructor(host: HostElement, context: T, initialValue?: ContextType<T>);\n  constructor(\n    host: HostElement,\n    contextOrOptions: T | Options<T>,\n    initialValue?: ContextType<T>\n  ) {\n    super(\n      (contextOrOptions as Options<T>).context !== undefined\n        ? (contextOrOptions as Options<T>).initialValue\n        : initialValue\n    );\n    this.host = host;\n    if ((contextOrOptions as Options<T>).context !== undefined) {\n      this.context = (contextOrOptions as Options<T>).context;\n    } else {\n      this.context = contextOrOptions as T;\n    }\n    this.attachListeners();\n    this.host.addController?.(this);\n  }\n\n  onContextRequest = (\n    ev: ContextRequestEvent<Context<unknown, unknown>>\n  ): void => {\n    // Only call the callback if the context matches.\n    if (ev.context !== this.context) {\n      return;\n    }\n    // Also, in case an element is a consumer AND a provider\n    // of the same context, we want to avoid the element to self-register.\n    const consumerHost = ev.contextTarget ?? ev.composedPath()[0];\n    if (consumerHost === this.host) {\n      return;\n    }\n    ev.stopPropagation();\n    this.addCallback(ev.callback, consumerHost, ev.subscribe);\n  };\n\n  /**\n   * When we get a provider request event, that means a child of this element\n   * has just woken up. If it's a provider of our context, then we may need to\n   * re-parent our subscriptions, because is a more specific provider than us\n   * for its subtree.\n   */\n  onProviderRequest = (\n    ev: ContextProviderEvent<Context<unknown, unknown>>\n  ): void => {\n    // Ignore events when the context doesn't match.\n    if (ev.context !== this.context) {\n      return;\n    }\n    // Also, in case an element is a consumer AND a provider\n    // of the same context it shouldn't provide to itself.\n    const childProviderHost = ev.contextTarget ?? ev.composedPath()[0];\n    if (childProviderHost === this.host) {\n      return;\n    }\n    // Re-parent all of our subscriptions in case this new child provider\n    // should take them over.\n    const seen = new Set<unknown>();\n    for (const [callback, {consumerHost}] of this.subscriptions) {\n      // Prevent infinite loops in the case where a one host element\n      // is providing the same context multiple times.\n      //\n      // While normally it's a no-op to attempt to re-parent a subscription\n      // that already has its proper parent, in the case where there's more\n      // than one ValueProvider for the same context on the same hostElement,\n      // they will each call the consumer, and since they will each have their\n      // own dispose function, a well behaved consumer will notice the change\n      // in dispose function and call their old one.\n      //\n      // This will cause the subscriptions to thrash, but worse, without this\n      // set check here, we can end up in an infinite loop, as we add and remove\n      // the same subscriptions onto the end of the map over and over.\n      if (seen.has(callback)) {\n        continue;\n      }\n      seen.add(callback);\n      consumerHost.dispatchEvent(\n        new ContextRequestEvent(this.context, consumerHost, callback, true)\n      );\n    }\n    ev.stopPropagation();\n  };\n\n  private attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n    this.host.addEventListener('context-provider', this.onProviderRequest);\n  }\n\n  hostConnected(): void {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context, this.host));\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Context} from './create-context.js';\nimport {ContextCallback, ContextRequestEvent} from './context-request-event.js';\nimport {ContextProviderEvent} from './controllers/context-provider.js';\n\n/**\n * A ContextRoot can be used to gather unsatisfied context requests and\n * re-dispatch them when new providers which satisfy matching context keys are\n * available.\n *\n * This allows providers to be added to a DOM tree, or upgraded, after the\n * consumers.\n */\nexport class ContextRoot {\n  private pendingContextRequests = new Map<\n    Context<unknown, unknown>,\n    {\n      // The WeakMap lets us detect if we're seen an element/callback pair yet,\n      // without needing to iterate the `requests` array\n      callbacks: WeakMap<HTMLElement, WeakSet<ContextCallback<unknown>>>;\n\n      // Requests lets us iterate over every element/callback that we need to\n      // replay context events for\n      // Both the element and callback must be stored in WeakRefs because the\n      // callback most likely has a strong ref to the element.\n      requests: Array<{\n        elementRef: WeakRef<HTMLElement>;\n        callbackRef: WeakRef<ContextCallback<unknown>>;\n      }>;\n    }\n  >();\n\n  /**\n   * Attach the ContextRoot to a given element to intercept `context-request` and\n   * `context-provider` events.\n   *\n   * @param element an element to add event listeners to\n   */\n  attach(element: HTMLElement): void {\n    element.addEventListener('context-request', this.onContextRequest);\n    element.addEventListener('context-provider', this.onContextProvider);\n  }\n\n  /**\n   * Removes the ContextRoot event listeners from a given element.\n   *\n   * @param element an element from which to remove event listeners\n   */\n  detach(element: HTMLElement): void {\n    element.removeEventListener('context-request', this.onContextRequest);\n    element.removeEventListener('context-provider', this.onContextProvider);\n  }\n\n  private onContextProvider = (\n    event: ContextProviderEvent<Context<unknown, unknown>>\n  ) => {\n    const pendingRequestData = this.pendingContextRequests.get(event.context);\n    if (pendingRequestData === undefined) {\n      // No pending requests for this context at this time\n      return;\n    }\n\n    // Clear our list. Any still unsatisfied requests will re-add themselves\n    // when we dispatch the events below.\n    this.pendingContextRequests.delete(event.context);\n\n    // Loop over all pending requests and re-dispatch them from their source\n    const {requests} = pendingRequestData;\n    for (const {elementRef, callbackRef} of requests) {\n      const element = elementRef.deref();\n      const callback = callbackRef.deref();\n\n      if (element === undefined || callback === undefined) {\n        // The element was GC'ed. Do nothing.\n      } else {\n        // Re-dispatch if we still have the element and callback\n        element.dispatchEvent(\n          new ContextRequestEvent(event.context, element, callback, true)\n        );\n      }\n    }\n  };\n\n  private onContextRequest = (\n    event: ContextRequestEvent<Context<unknown, unknown>>\n  ) => {\n    // Events that are not subscribing should not be buffered\n    if (event.subscribe !== true) {\n      return;\n    }\n\n    // Note, it's important to use the initial target\n    // since that's the requesting element and the event may be re-targeted\n    // to an outer host element.\n    const element = (event.contextTarget ??\n      event.composedPath()[0]) as HTMLElement;\n    const callback = event.callback;\n\n    let pendingContextRequests = this.pendingContextRequests.get(event.context);\n    if (pendingContextRequests === undefined) {\n      this.pendingContextRequests.set(\n        event.context,\n        (pendingContextRequests = {\n          callbacks: new WeakMap(),\n          requests: [],\n        })\n      );\n    }\n\n    let callbacks = pendingContextRequests.callbacks.get(element);\n    if (callbacks === undefined) {\n      pendingContextRequests.callbacks.set(\n        element,\n        (callbacks = new WeakSet())\n      );\n    }\n\n    if (callbacks.has(callback)) {\n      // We're already tracking this element/callback pair\n      return;\n    }\n\n    callbacks.add(callback);\n    pendingContextRequests.requests.push({\n      elementRef: new WeakRef(element),\n      callbackRef: new WeakRef(callback),\n    });\n  };\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ReactiveElement} from '@lit/reactive-element';\nimport {Context} from '../create-context.js';\nimport {ContextProvider} from '../controllers/context-provider.js';\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\n/**\n * A property decorator that adds a ContextProvider controller to the component\n * making it respond to any `context-request` events from its children consumer.\n *\n * @param context A Context identifier value created via `createContext`\n *\n * @example\n *\n * ```ts\n * import {provide} from '@lit/context';\n * import {Logger} from 'my-logging-library';\n * import {loggerContext} from './logger-context.js';\n *\n * class MyElement {\n *   @provide({context: loggerContext})\n *   logger = new Logger();\n * }\n * ```\n * @category Decorator\n */\nexport function provide<ValueType>({\n  context: context,\n}: {\n  context: Context<unknown, ValueType>;\n}): ProvideDecorator<ValueType> {\n  return ((\n    protoOrTarget: ClassAccessorDecoratorTarget<ReactiveElement, ValueType>,\n    nameOrContext:\n      | PropertyKey\n      | ClassAccessorDecoratorContext<ReactiveElement, ValueType>\n  ) => {\n    // Map of instances to controllers\n    const controllerMap = new WeakMap<\n      ReactiveElement,\n      ContextProvider<Context<unknown, ValueType>>\n    >();\n    if (typeof nameOrContext === 'object') {\n      // Standard decorators branch\n      return {\n        get(this: ReactiveElement) {\n          return protoOrTarget.get.call(this);\n        },\n        set(this: ReactiveElement, value: ValueType) {\n          controllerMap.get(this)!.setValue(value);\n          return protoOrTarget.set.call(this, value);\n        },\n        init(this: ReactiveElement, value: ValueType) {\n          controllerMap.set(\n            this,\n            new ContextProvider(this, {context, initialValue: value})\n          );\n          return value;\n        },\n      };\n    } else {\n      // Experimental decorators branch\n      (protoOrTarget.constructor as typeof ReactiveElement).addInitializer(\n        (element: ReactiveElement): void => {\n          controllerMap.set(element, new ContextProvider(element, {context}));\n        }\n      );\n      // proxy any existing setter for this property and use it to\n      // notify the controller of an updated value\n      const descriptor = Object.getOwnPropertyDescriptor(\n        protoOrTarget,\n        nameOrContext\n      );\n      let newDescriptor: PropertyDescriptor;\n      if (descriptor === undefined) {\n        const valueMap = new WeakMap<ReactiveElement, ValueType>();\n        newDescriptor = {\n          get(this: ReactiveElement) {\n            return valueMap.get(this);\n          },\n          set(this: ReactiveElement, value: ValueType) {\n            controllerMap.get(this)!.setValue(value);\n            valueMap.set(this, value);\n          },\n          configurable: true,\n          enumerable: true,\n        };\n      } else {\n        const oldSetter = descriptor.set;\n        newDescriptor = {\n          ...descriptor,\n          set(this: ReactiveElement, value: ValueType) {\n            controllerMap.get(this)!.setValue(value);\n            oldSetter?.call(this, value);\n          },\n        };\n      }\n      Object.defineProperty(protoOrTarget, nameOrContext, newDescriptor);\n      return;\n    }\n  }) as ProvideDecorator<ValueType>;\n}\n\n/**\n * Generates a public interface type that removes private and protected fields.\n * This allows accepting otherwise compatible versions of the type (e.g. from\n * multiple copies of the same package in `node_modules`).\n */\ntype Interface<T> = {\n  [K in keyof T]: T[K];\n};\n\ntype ProvideDecorator<ContextType> = {\n  // legacy\n  <\n    K extends PropertyKey,\n    Proto extends Interface<Omit<ReactiveElement, 'renderRoot'>>,\n  >(\n    protoOrDescriptor: Proto,\n    name?: K\n  ): FieldMustMatchContextType<Proto, K, ContextType>;\n\n  // standard\n  <\n    C extends Interface<Omit<ReactiveElement, 'renderRoot'>>,\n    V extends ContextType,\n  >(\n    value: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): void;\n};\n\n// Note TypeScript requires the return type of a decorator to be `void | any`\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype DecoratorReturn = void | any;\n\ntype FieldMustMatchContextType<Obj, Key extends PropertyKey, ContextType> =\n  // First we check whether the object has the property as a required field\n  Obj extends Record<Key, infer ProvidingType>\n    ? // Ok, it does, just check whether it's ok to assign the\n      // provided type to the consuming field\n      [ProvidingType] extends [ContextType]\n      ? DecoratorReturn\n      : {\n          message: 'providing field not assignable to context';\n          context: ContextType;\n          provided: ProvidingType;\n        }\n    : // Next we check whether the object has the property as an optional field\n      Obj extends Partial<Record<Key, infer Providing>>\n      ? // Check assignability again. Note that we have to include undefined\n        // here on the providing type because it's optional.\n        [Providing | undefined] extends [ContextType]\n        ? DecoratorReturn\n        : {\n            message: 'providing field not assignable to context';\n            context: ContextType;\n            consuming: Providing | undefined;\n          }\n      : // Ok, the field isn't present, so either someone's using provide\n        // manually, i.e. not as a decorator (maybe don't do that! but if you do,\n        // you're on your own for your type checking, sorry), or the field is\n        // private, in which case we can't check it.\n        DecoratorReturn;\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ReactiveElement} from '@lit/reactive-element';\nimport {ContextConsumer} from '../controllers/context-consumer.js';\nimport {Context} from '../create-context.js';\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\n/**\n * A property decorator that adds a ContextConsumer controller to the component\n * which will try and retrieve a value for the property via the Context API.\n *\n * @param context A Context identifier value created via `createContext`\n * @param subscribe An optional boolean which when true allows the value to be updated\n *   multiple times.\n *\n * @example\n *\n * ```ts\n * import {consume} from '@lit/context';\n * import {loggerContext, Logger} from 'community-protocols/logger';\n *\n * class MyElement {\n *   @consume({context: loggerContext})\n *   logger?: Logger;\n *\n *   doThing() {\n *     this.logger!.log('thing was done');\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function consume<ValueType>({\n  context,\n  subscribe,\n}: {\n  context: Context<unknown, ValueType>;\n  subscribe?: boolean;\n}): ConsumeDecorator<ValueType> {\n  return ((\n    protoOrTarget: ClassAccessorDecoratorTarget<ReactiveElement, ValueType>,\n    nameOrContext:\n      | PropertyKey\n      | ClassAccessorDecoratorContext<ReactiveElement, ValueType>\n  ) => {\n    if (typeof nameOrContext === 'object') {\n      // Standard decorators branch\n      nameOrContext.addInitializer(function () {\n        new ContextConsumer(this, {\n          context,\n          callback: (value) => {\n            protoOrTarget.set.call(this, value);\n          },\n          subscribe,\n        });\n      });\n    } else {\n      // Experimental decorators branch\n      (protoOrTarget.constructor as typeof ReactiveElement).addInitializer(\n        (element: ReactiveElement): void => {\n          new ContextConsumer(element, {\n            context,\n            callback: (value) => {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (element as any)[nameOrContext] = value;\n            },\n            subscribe,\n          });\n        }\n      );\n    }\n  }) as ConsumeDecorator<ValueType>;\n}\n\n/**\n * Generates a public interface type that removes private and protected fields.\n * This allows accepting otherwise incompatible versions of the type (e.g. from\n * multiple copies of the same package in `node_modules`).\n */\ntype Interface<T> = {\n  [K in keyof T]: T[K];\n};\n\ntype ConsumeDecorator<ValueType> = {\n  // legacy\n  <\n    K extends PropertyKey,\n    Proto extends Interface<Omit<ReactiveElement, 'renderRoot'>>,\n  >(\n    protoOrDescriptor: Proto,\n    name?: K\n  ): FieldMustMatchProvidedType<Proto, K, ValueType>;\n\n  // standard\n  <\n    C extends Interface<Omit<ReactiveElement, 'renderRoot'>>,\n    V extends ValueType,\n  >(\n    value: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): void;\n};\n\n// Note TypeScript requires the return type of a decorator to be `void | any`\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype DecoratorReturn = void | any;\n\ntype FieldMustMatchProvidedType<Obj, Key extends PropertyKey, ProvidedType> =\n  // First we check whether the object has the property as a required field\n  Obj extends Record<Key, infer ConsumingType>\n    ? // Ok, it does, just check whether it's ok to assign the\n      // provided type to the consuming field\n      [ProvidedType] extends [ConsumingType]\n      ? DecoratorReturn\n      : {\n          message: 'provided type not assignable to consuming field';\n          provided: ProvidedType;\n          consuming: ConsumingType;\n        }\n    : // Next we check whether the object has the property as an optional field\n      Obj extends Partial<Record<Key, infer ConsumingType>>\n      ? // Check assignability again. Note that we have to include undefined\n        // here on the consuming type because it's optional.\n        [ProvidedType] extends [ConsumingType | undefined]\n        ? DecoratorReturn\n        : {\n            message: 'provided type not assignable to consuming field';\n            provided: ProvidedType;\n            consuming: ConsumingType | undefined;\n          }\n      : // Ok, the field isn't present, so either someone's using consume\n        // manually, i.e. not as a decorator (maybe don't do that! but if you do,\n        // you're on your own for your type checking, sorry), or the field is\n        // private, in which case we can't check it.\n        DecoratorReturn;\n"],
  "mappings": "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",
  "names": []
}
