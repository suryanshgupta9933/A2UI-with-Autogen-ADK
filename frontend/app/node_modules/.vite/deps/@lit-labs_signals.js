import {
  AsyncDirective
} from "./chunk-YQYBIKLD.js";
import "./chunk-PW6KGI4D.js";
import {
  html,
  svg
} from "./chunk-CDMAZYDT.js";
import {
  Signal
} from "./chunk-ZDAEO5LF.js";
import "./chunk-DI5EVPBB.js";
import {
  directive
} from "./chunk-2AVGUHGC.js";
import "./chunk-PZ5AY32C.js";

// ../packages/lit/node_modules/@lit-labs/signals/development/lib/signal-watcher.js
var signalWatcherBrand = /* @__PURE__ */ Symbol("SignalWatcherBrand");
var elementFinalizationRegistry = new FinalizationRegistry(({ watcher, signal: signal2 }) => {
  watcher.unwatch(signal2);
});
var elementForWatcher = /* @__PURE__ */ new WeakMap();
function SignalWatcher(Base) {
  if (Base[signalWatcherBrand] === true) {
    console.warn("SignalWatcher should not be applied to the same class more than once.");
    return Base;
  }
  class SignalWatcher2 extends Base {
    constructor() {
      super(...arguments);
      this.__forceUpdateSignal = new Signal.State(0);
      this.__forcingUpdate = false;
      this.__doFullRender = true;
      this.__pendingWatches = /* @__PURE__ */ new Set();
    }
    __watch() {
      if (this.__watcher !== void 0) {
        return;
      }
      this.__performUpdateSignal = new Signal.Computed(() => {
        this.__forceUpdateSignal.get();
        super.performUpdate();
      });
      const watcher = this.__watcher = new Signal.subtle.Watcher(function() {
        const el = elementForWatcher.get(this);
        if (el === void 0) {
          return;
        }
        if (el.__forcingUpdate === false) {
          el.requestUpdate();
        }
        this.watch();
      });
      elementForWatcher.set(watcher, this);
      elementFinalizationRegistry.register(this, {
        watcher,
        signal: this.__performUpdateSignal
      });
      watcher.watch(this.__performUpdateSignal);
    }
    __unwatch() {
      if (this.__watcher === void 0) {
        return;
      }
      this.__watcher.unwatch(this.__performUpdateSignal);
      this.__performUpdateSignal = void 0;
      this.__watcher = void 0;
    }
    performUpdate() {
      if (!this.isUpdatePending) {
        return;
      }
      this.__watch();
      this.__forcingUpdate = true;
      this.__forceUpdateSignal.set(this.__forceUpdateSignal.get() + 1);
      this.__forcingUpdate = false;
      this.__performUpdateSignal.get();
    }
    update(changedProperties) {
      try {
        if (this.__doFullRender) {
          this.__doFullRender = false;
          super.update(changedProperties);
        } else {
          this.__pendingWatches.forEach((d) => d.commit());
        }
      } finally {
        this.isUpdatePending = false;
        this.__pendingWatches.clear();
      }
    }
    requestUpdate(name, oldValue, options) {
      this.__doFullRender = true;
      super.requestUpdate(name, oldValue, options);
    }
    connectedCallback() {
      super.connectedCallback();
      this.requestUpdate();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      queueMicrotask(() => {
        if (this.isConnected === false) {
          this.__unwatch();
        }
      });
    }
    /**
     * Enqueues an update caused by a signal change observed by a watch()
     * directive.
     *
     * Note: the method is not part of the public API and is subject to change.
     * In particular, it may be removed if the watch() directive is updated to
     * work with standalone lit-html templates.
     *
     * @internal
     */
    _updateWatchDirective(d) {
      this.__pendingWatches.add(d);
      const shouldRender = this.__doFullRender;
      this.requestUpdate();
      this.__doFullRender = shouldRender;
    }
    /**
     * Clears a watch() directive from the set of pending watches.
     *
     * Note: the method is not part of the public API and is subject to change.
     *
     * @internal
     */
    _clearWatchDirective(d) {
      this.__pendingWatches.delete(d);
    }
  }
  return SignalWatcher2;
}

// ../packages/lit/node_modules/@lit-labs/signals/development/lib/watch.js
var WatchDirective = class extends AsyncDirective {
  __watch() {
    if (this.__watcher !== void 0) {
      return;
    }
    this.__computed = new Signal.Computed(() => {
      var _a;
      return (_a = this.__signal) === null || _a === void 0 ? void 0 : _a.get();
    });
    const watcher = this.__watcher = new Signal.subtle.Watcher(() => {
      var _a;
      (_a = this.__host) === null || _a === void 0 ? void 0 : _a._updateWatchDirective(this);
      watcher.watch();
    });
    watcher.watch(this.__computed);
  }
  __unwatch() {
    var _a;
    if (this.__watcher !== void 0) {
      this.__watcher.unwatch(this.__computed);
      this.__computed = void 0;
      this.__watcher = void 0;
      (_a = this.__host) === null || _a === void 0 ? void 0 : _a._clearWatchDirective(this);
    }
  }
  commit() {
    this.setValue(Signal.subtle.untrack(() => {
      var _a;
      return (_a = this.__computed) === null || _a === void 0 ? void 0 : _a.get();
    }));
  }
  render(signal2) {
    return Signal.subtle.untrack(() => signal2.get());
  }
  update(part, [signal2]) {
    var _a, _b;
    (_a = this.__host) !== null && _a !== void 0 ? _a : this.__host = (_b = part.options) === null || _b === void 0 ? void 0 : _b.host;
    if (signal2 !== this.__signal && this.__signal !== void 0) {
      this.__unwatch();
    }
    this.__signal = signal2;
    this.__watch();
    return Signal.subtle.untrack(() => this.__computed.get());
  }
  disconnected() {
    this.__unwatch();
  }
  reconnected() {
    this.__watch();
  }
};
var watch = directive(WatchDirective);

// ../packages/lit/node_modules/@lit-labs/signals/development/lib/html-tag.js
var withWatch = (coreTag) => (strings, ...values) => {
  return coreTag(strings, ...values.map((v) => v instanceof Signal.State || v instanceof Signal.Computed ? watch(v) : v));
};
var html2 = withWatch(html);
var svg2 = withWatch(svg);

// ../packages/lit/node_modules/@lit-labs/signals/development/index.js
var State = Signal.State;
var Computed = Signal.Computed;
var signal = (value, options) => new Signal.State(value, options);
var computed = (callback, options) => new Signal.Computed(callback, options);
export {
  Computed,
  Signal,
  SignalWatcher,
  State,
  WatchDirective,
  computed,
  html2 as html,
  signal,
  svg2 as svg,
  watch,
  withWatch
};
//# sourceMappingURL=@lit-labs_signals.js.map
