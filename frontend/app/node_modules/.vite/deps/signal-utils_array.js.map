{
  "version": 3,
  "sources": ["../../../../packages/lit/node_modules/signal-utils/src/array.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-explicit-any */\n// Unfortunately, TypeScript's ability to do inference *or* type-checking in a\n// `Proxy`'s body is very limited, so we have to use a number of casts `as any`\n// to make the internal accesses work. The type safety of these is guaranteed at\n// the *call site* instead of within the body: you cannot do `Array.blah` in TS,\n// and it will blow up in JS in exactly the same way, so it is safe to assume\n// that properties within the getter have the correct type in TS.\n\nimport { Signal } from \"signal-polyfill\";\nimport { createStorage } from \"./-private/util.ts\";\n\nconst ARRAY_GETTER_METHODS = new Set<string | symbol | number>([\n  Symbol.iterator,\n  \"concat\",\n  \"entries\",\n  \"every\",\n  \"filter\",\n  \"find\",\n  \"findIndex\",\n  \"flat\",\n  \"flatMap\",\n  \"forEach\",\n  \"includes\",\n  \"indexOf\",\n  \"join\",\n  \"keys\",\n  \"lastIndexOf\",\n  \"map\",\n  \"reduce\",\n  \"reduceRight\",\n  \"slice\",\n  \"some\",\n  \"values\",\n]);\n\n// For these methods, `Array` itself immediately gets the `.length` to return\n// after invoking them.\nconst ARRAY_WRITE_THEN_READ_METHODS = new Set<string | symbol>([\n  \"fill\",\n  \"push\",\n  \"unshift\",\n]);\n\nfunction convertToInt(prop: number | string | symbol): number | null {\n  if (typeof prop === \"symbol\") return null;\n\n  const num = Number(prop);\n\n  if (isNaN(num)) return null;\n\n  return num % 1 === 0 ? num : null;\n}\n\n// This rule is correct in the general case, but it doesn't understand\n// declaration merging, which is how we're using the interface here. This says\n// `SignalArray` acts just like `Array<T>`, but also has the properties\n// declared via the `class` declaration above -- but without the cost of a\n// subclass, which is much slower than the proxied array behavior. That is: a\n// `SignalArray` *is* an `Array`, just with a proxy in front of accessors and\n// setters, rather than a subclass of an `Array` which would be de-optimized by\n// the browsers.\n//\nexport interface SignalArray<T = unknown> extends Array<T> {}\n\nexport class SignalArray<T = unknown> {\n  /**\n   * Creates an array from an iterable object.\n   * @param iterable An iterable object to convert to an array.\n   */\n  static from<T>(iterable: Iterable<T> | ArrayLike<T>): SignalArray<T>;\n\n  /**\n   * Creates an array from an iterable object.\n   * @param iterable An iterable object to convert to an array.\n   * @param mapfn A mapping function to call on every element of the array.\n   * @param thisArg Value of 'this' used to invoke the mapfn.\n   */\n  static from<T, U>(\n    iterable: Iterable<T> | ArrayLike<T>,\n    mapfn: (v: T, k: number) => U,\n    thisArg?: unknown,\n  ): SignalArray<U>;\n\n  static from<T, U>(\n    iterable: Iterable<T> | ArrayLike<T>,\n    mapfn?: (v: T, k: number) => U,\n    thisArg?: unknown,\n  ): SignalArray<T> | SignalArray<U> {\n    return mapfn\n      ? new SignalArray(Array.from(iterable, mapfn, thisArg))\n      : new SignalArray(Array.from(iterable));\n  }\n\n  static of<T>(...arr: T[]): SignalArray<T> {\n    return new SignalArray(arr);\n  }\n\n  constructor(arr: T[] = []) {\n    let clone = arr.slice();\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let self = this;\n\n    let boundFns = new Map<string | symbol, (...args: any[]) => any>();\n\n    /**\n      Flag to track whether we have *just* intercepted a call to `.push()` or\n      `.unshift()`, since in those cases (and only those cases!) the `Array`\n      itself checks `.length` to return from the function call.\n     */\n    let nativelyAccessingLengthFromPushOrUnshift = false;\n\n    return new Proxy(clone, {\n      get(target, prop /*, _receiver */) {\n        let index = convertToInt(prop);\n\n        if (index !== null) {\n          self.#readStorageFor(index);\n          self.#collection.get();\n\n          return target[index];\n        }\n\n        if (prop === \"length\") {\n          // If we are reading `.length`, it may be a normal user-triggered\n          // read, or it may be a read triggered by Array itself. In the latter\n          // case, it is because we have just done `.push()` or `.unshift()`; in\n          // that case it is safe not to mark this as a *read* operation, since\n          // calling `.push()` or `.unshift()` cannot otherwise be part of a\n          // \"read\" operation safely, and if done during an *existing* read\n          // (e.g. if the user has already checked `.length` *prior* to this),\n          // that will still trigger the mutation-after-consumption assertion.\n          if (nativelyAccessingLengthFromPushOrUnshift) {\n            nativelyAccessingLengthFromPushOrUnshift = false;\n          } else {\n            self.#collection.get();\n          }\n\n          return target[prop];\n        }\n\n        // Here, track that we are doing a `.push()` or `.unshift()` by setting\n        // the flag to `true` so that when the `.length` is read by `Array` (see\n        // immediately above), it knows not to dirty the collection.\n        if (ARRAY_WRITE_THEN_READ_METHODS.has(prop)) {\n          nativelyAccessingLengthFromPushOrUnshift = true;\n        }\n\n        if (ARRAY_GETTER_METHODS.has(prop)) {\n          let fn = boundFns.get(prop);\n\n          if (fn === undefined) {\n            fn = (...args) => {\n              self.#collection.get();\n              return (target as any)[prop](...args);\n            };\n\n            boundFns.set(prop, fn);\n          }\n\n          return fn;\n        }\n\n        return (target as any)[prop];\n      },\n\n      set(target, prop, value /*, _receiver */) {\n        (target as any)[prop] = value;\n\n        let index = convertToInt(prop);\n\n        if (index !== null) {\n          self.#dirtyStorageFor(index);\n          self.#collection.set(null);\n        } else if (prop === \"length\") {\n          self.#collection.set(null);\n        }\n\n        return true;\n      },\n\n      getPrototypeOf() {\n        return SignalArray.prototype;\n      },\n    }) as SignalArray<T>;\n  }\n\n  #collection = createStorage();\n\n  #storages = new Map<PropertyKey, Signal.State<null>>();\n\n  #readStorageFor(index: number) {\n    let storage = this.#storages.get(index);\n\n    if (storage === undefined) {\n      storage = createStorage();\n      this.#storages.set(index, storage);\n    }\n\n    storage.get();\n  }\n\n  #dirtyStorageFor(index: number): void {\n    const storage = this.#storages.get(index);\n\n    if (storage) {\n      storage.set(null);\n    }\n  }\n}\n\n// Ensure instanceof works correctly\nObject.setPrototypeOf(SignalArray.prototype, Array.prototype);\n\nexport function signalArray<Item>(x?: Item[]) {\n  return new SignalArray(x);\n}\n"],
  "mappings": ";;;;;;;AAWA,IAAMA,uBAAuB,oBAAIC,IAA8B,CAC7DC,OAAOC,UACP,UACA,WACA,SACA,UACA,QACA,aACA,QACA,WACA,WACA,YACA,WACA,QACA,QACA,eACA,OACA,UACA,eACA,SACA,QACA,QAAQ,CACT;AAID,IAAMC,gCAAgC,oBAAIH,IAAqB,CAC7D,QACA,QACA,SAAS,CACV;AAED,SAASI,aAAaC,MAA+C;AACnE,MAAI,OAAOA,SAAS,SAAU,QAAO;AAErC,QAAMC,MAAMC,OAAOF,IAAI;AAEvB,MAAIG,MAAMF,GAAG,EAAG,QAAO;AAEvB,SAAOA,MAAM,MAAM,IAAIA,MAAM;AAC/B;AAaO,IAAMG,cAAN,MAAMA,aAAyB;;;;;;;;;;;EAmBpC,OAAOC,KACLC,UACAC,OACAC,SACiC;AACjC,WAAOD,QACH,IAAIH,aAAYK,MAAMJ,KAAKC,UAAUC,OAAOC,OAAO,CAAC,IACpD,IAAIJ,aAAYK,MAAMJ,KAAKC,QAAQ,CAAC;EAC1C;EAEA,OAAOI,MAASC,KAA0B;AACxC,WAAO,IAAIP,aAAYO,GAAG;EAC5B;EAEAC,YAAYD,MAAW,CAAA,GAAI;AACzB,QAAIE,QAAQF,IAAIG,MAAK;AAErB,QAAIC,OAAO;AAEX,QAAIC,WAAW,oBAAIC,IAAG;AAOtB,QAAIC,2CAA2C;AAE/C,WAAO,IAAIC,MAAMN,OAAO;MACtBO,IAAIC,QAAQrB,MAAuB;AACjC,YAAIsB,QAAQvB,aAAaC,IAAI;AAE7B,YAAIsB,UAAU,MAAM;AAClBP,eAAK,gBAAgBO,KAAK;AAC1BP,eAAK,YAAYK,IAAG;AAEpB,iBAAOC,OAAOC,KAAK;QACrB;AAEA,YAAItB,SAAS,UAAU;AASrB,cAAIkB,0CAA0C;AAC5CA,uDAA2C;UAC7C,OAAO;AACLH,iBAAK,YAAYK,IAAG;UACtB;AAEA,iBAAOC,OAAOrB,IAAI;QACpB;AAKA,YAAIF,8BAA8ByB,IAAIvB,IAAI,GAAG;AAC3CkB,qDAA2C;QAC7C;AAEA,YAAIxB,qBAAqB6B,IAAIvB,IAAI,GAAG;AAClC,cAAIwB,KAAKR,SAASI,IAAIpB,IAAI;AAE1B,cAAIwB,OAAOC,QAAW;AACpBD,iBAAKA,IAAIE,SAAS;AAChBX,mBAAK,YAAYK,IAAG;AACpB,qBAAQC,OAAerB,IAAI,EAAE,GAAG0B,IAAI;;AAGtCV,qBAASW,IAAI3B,MAAMwB,EAAE;UACvB;AAEA,iBAAOA;QACT;AAEA,eAAQH,OAAerB,IAAI;;MAG7B2B,IAAIN,QAAQrB,MAAM4B,OAAwB;AACvCP,eAAerB,IAAI,IAAI4B;AAExB,YAAIN,QAAQvB,aAAaC,IAAI;AAE7B,YAAIsB,UAAU,MAAM;AAClBP,eAAK,iBAAiBO,KAAK;AAC3BP,eAAK,YAAYY,IAAI,IAAI;QAC3B,WAAW3B,SAAS,UAAU;AAC5Be,eAAK,YAAYY,IAAI,IAAI;QAC3B;AAEA,eAAO;;MAGTE,iBAAiB;AACf,eAAOzB,aAAY0B;MACrB;IACF,CAAC;EACH;EAEA,cAAcC,cAAa;EAE3B,YAAY,oBAAId,IAAG;EAEnB,gBAAgBK,OAAe;AAC7B,QAAIU,UAAU,KAAK,UAAUZ,IAAIE,KAAK;AAEtC,QAAIU,YAAYP,QAAW;AACzBO,gBAAUD,cAAa;AACvB,WAAK,UAAUJ,IAAIL,OAAOU,OAAO;IACnC;AAEAA,YAAQZ,IAAG;EACb;EAEA,iBAAiBE,OAAqB;AACpC,UAAMU,UAAU,KAAK,UAAUZ,IAAIE,KAAK;AAExC,QAAIU,SAAS;AACXA,cAAQL,IAAI,IAAI;IAClB;EACF;AACF;AAGAM,OAAOC,eAAe9B,YAAY0B,WAAWrB,MAAMqB,SAAS;AAErD,SAASK,YAAkBC,GAAY;AAC5C,SAAO,IAAIhC,YAAYgC,CAAC;AAC1B;",
  "names": ["ARRAY_GETTER_METHODS", "Set", "Symbol", "iterator", "ARRAY_WRITE_THEN_READ_METHODS", "convertToInt", "prop", "num", "Number", "isNaN", "SignalArray", "from", "iterable", "mapfn", "thisArg", "Array", "of", "arr", "constructor", "clone", "slice", "self", "boundFns", "Map", "nativelyAccessingLengthFromPushOrUnshift", "Proxy", "get", "target", "index", "has", "fn", "undefined", "args", "set", "value", "getPrototypeOf", "prototype", "createStorage", "storage", "Object", "setPrototypeOf", "signalArray", "x"]
}
