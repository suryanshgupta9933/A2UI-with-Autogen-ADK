{"version":3,"file":"signal-watcher.js","sources":["../src/lib/signal-watcher.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {PropertyDeclaration, PropertyValueMap, ReactiveElement} from 'lit';\nimport {Signal} from 'signal-polyfill';\nimport {WatchDirective} from './watch.js';\n\ntype ReactiveElementConstructor = abstract new (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: any[]\n) => ReactiveElement;\n\nexport interface SignalWatcher extends ReactiveElement {\n  _updateWatchDirective(d: WatchDirective<unknown>): void;\n  _clearWatchDirective(d: WatchDirective<unknown>): void;\n}\n\ninterface SignalWatcherInterface extends SignalWatcher {}\ninterface SignalWatcherInternal extends SignalWatcher {\n  __forcingUpdate: boolean;\n}\n\nconst signalWatcherBrand: unique symbol = Symbol('SignalWatcherBrand');\n\n// Memory management: We need to ensure that we don't leak memory by creating a\n// reference cycle between an element and its watcher, which then it kept alive\n// by the signals it watches. To avoid this, we break the cycle by using a\n// WeakMap to store the watcher for each element, and a FinalizationRegistry to\n// clean up the watcher when the element is garbage collected.\n\nconst elementFinalizationRegistry = new FinalizationRegistry<{\n  watcher: Signal.subtle.Watcher;\n  signal: Signal.Computed<void>;\n}>(({watcher, signal}) => {\n  watcher.unwatch(signal);\n});\n\nconst elementForWatcher = new WeakMap<\n  Signal.subtle.Watcher,\n  SignalWatcherInternal\n>();\n\n/**\n * Adds the ability for a LitElement or other ReactiveElement class to\n * watch for access to signals during the update lifecycle and trigger a new\n * update when signals values change.\n */\nexport function SignalWatcher<T extends ReactiveElementConstructor>(\n  Base: T\n): T {\n  // Only apply the mixin once\n  if ((Base as typeof SignalWatcher)[signalWatcherBrand] === true) {\n    console.warn(\n      'SignalWatcher should not be applied to the same class more than once.'\n    );\n    return Base;\n  }\n\n  abstract class SignalWatcher extends Base implements SignalWatcherInterface {\n    static [signalWatcherBrand]: true;\n\n    private __watcher?: Signal.subtle.Watcher;\n\n    private __watch() {\n      if (this.__watcher !== undefined) {\n        return;\n      }\n      // We create a fresh computed instead of just re-using the existing one\n      // because of https://github.com/proposal-signals/signal-polyfill/issues/27\n      this.__performUpdateSignal = new Signal.Computed(() => {\n        this.__forceUpdateSignal.get();\n        super.performUpdate();\n      });\n      const watcher = (this.__watcher = new Signal.subtle.Watcher(function (\n        this: Signal.subtle.Watcher\n      ) {\n        // All top-level references in this function body must either be `this`\n        // (the watcher) or a module global to prevent this closure from keeping\n        // the enclosing scopes alive, which would keep the element alive. So\n        // The only two references are `this` and `elementForWatcher`.\n        const el = elementForWatcher.get(this);\n        if (el === undefined) {\n          // The element was garbage collected, so we can stop watching.\n          return;\n        }\n        if (el.__forcingUpdate === false) {\n          el.requestUpdate();\n        }\n        this.watch();\n      }));\n      elementForWatcher.set(watcher, this as unknown as SignalWatcherInternal);\n      elementFinalizationRegistry.register(this, {\n        watcher,\n        signal: this.__performUpdateSignal,\n      });\n      watcher.watch(this.__performUpdateSignal);\n    }\n\n    private __unwatch() {\n      if (this.__watcher === undefined) {\n        return;\n      }\n      this.__watcher.unwatch(this.__performUpdateSignal!);\n      this.__performUpdateSignal = undefined;\n      this.__watcher = undefined;\n    }\n\n    /**\n     * Used to force an uncached read of the __performUpdateSignal when we need\n     * to read the current value during an update.\n     *\n     * If https://github.com/tc39/proposal-signals/issues/151 is resolved, we\n     * won't need this.\n     */\n    private __forceUpdateSignal = new Signal.State(0);\n\n    /*\n     * This field is used within the watcher to determine if the watcher\n     * notification was triggered by our performUpdate() override. Because we\n     * force a fresh read of the __performUpdateSignal by changing value of the\n     * __forceUpdate signal, the watcher will be notified. But we're already\n     * performing an update, so we don't want to enqueue another one.\n     */\n    // @ts-expect-error This field is accessed in a watcher function with a\n    // different `this` context, so TypeScript can't see the access.\n    private __forcingUpdate = false;\n\n    /**\n     * A computed signal that wraps performUpdate() so that all signals that are\n     * accessed during the update lifecycle are tracked.\n     *\n     * __forceUpdateSignal is used to force an uncached read of this signal\n     * because updates may easily depend on non-signal values, so we must always\n     * re-run it.\n     */\n    private __performUpdateSignal?: Signal.Computed<void>;\n\n    /**\n     * Whether or not the next update should perform a full render, or if only\n     * pending watches should be committed.\n     *\n     * If requestUpdate() was called only because of watch() directive updates,\n     * then we can just commit those directives without a full render. If\n     * requestUpdate() was called for any other reason, we need to perform a\n     * full render, and don't need to separately commit the watch() directives.\n     *\n     * This is set to `true` initially, and whenever requestUpdate() is called\n     * outside of a watch() directive update. It is set to `false` when\n     * update() is called, so that a requestUpdate() is required to do another\n     * full render.\n     */\n    private __doFullRender = true;\n\n    /**\n     * Set of watch directives that have been updated since the last update.\n     * These will be committed in update() to ensure that the latest value is\n     * rendered and that all updates are batched.\n     */\n    private __pendingWatches = new Set<WatchDirective<unknown>>();\n\n    protected override performUpdate() {\n      if (!this.isUpdatePending) {\n        // super.performUpdate() performs this check, so we bail early so that\n        // we don't read the __performUpdateSignal when it's not going to access\n        // any signals. This keeps the last signals read as the sources so that\n        // we'll get notified of changes to them.\n        return;\n      }\n      // Always enable watching before an update, even if disconnected, so that\n      // we can track signals that are accessed during the update.\n      this.__watch();\n      // Force an uncached read of __performUpdateSignal\n      this.__forcingUpdate = true;\n      this.__forceUpdateSignal.set(this.__forceUpdateSignal.get() + 1);\n      this.__forcingUpdate = false;\n      // Always read from the signal to ensure that it's tracked\n      this.__performUpdateSignal!.get();\n    }\n\n    protected override update(\n      changedProperties: PropertyValueMap<this> | Map<PropertyKey, unknown>\n    ): void {\n      // We need a try block because both super.update() and\n      // WatchDirective.commit() can throw, and we need to ensure that post-\n      // update cleanup happens.\n      try {\n        if (this.__doFullRender) {\n          // Force future updates to not perform full renders by default.\n          this.__doFullRender = false;\n          super.update(changedProperties);\n        } else {\n          // For a partial render, just commit the pending watches.\n          // TODO (justinfagnani): Should we access each signal in a separate\n          // try block?\n          this.__pendingWatches.forEach((d) => d.commit());\n        }\n      } finally {\n        // If we didn't call super.update(), we need to set this to false\n        this.isUpdatePending = false;\n        this.__pendingWatches.clear();\n      }\n    }\n\n    override requestUpdate(\n      name?: PropertyKey | undefined,\n      oldValue?: unknown,\n      options?: PropertyDeclaration<unknown, unknown> | undefined\n    ): void {\n      this.__doFullRender = true;\n      super.requestUpdate(name, oldValue, options);\n    }\n\n    override connectedCallback(): void {\n      super.connectedCallback();\n      // Because we might have missed some signal updates while disconnected,\n      // we force a full render on the next update.\n      this.requestUpdate();\n    }\n\n    override disconnectedCallback(): void {\n      super.disconnectedCallback();\n      // Clean up the watcher earlier than the FinalizationRegistry will, to\n      // avoid memory pressure from signals holding references to the element\n      // via the watcher.\n      //\n      // This means that while disconnected, regular reactive property updates\n      // will trigger a re-render, but signal updates will not. To ensure that\n      // current signal usage is still correctly tracked, we re-enable watching\n      // in performUpdate() even while disconnected. From that point on, a\n      // disconnected element will be retained by the signals it accesses during\n      // the update lifecycle.\n      //\n      // We use queueMicrotask() to ensure that this cleanup does not happen\n      // because of moves in the DOM within the same task, such as removing an\n      // element with .remove() and then adding it back later with .append()\n      // in the same task. For example, repeat() works this way.\n      queueMicrotask(() => {\n        if (this.isConnected === false) {\n          this.__unwatch();\n        }\n      });\n    }\n\n    /**\n     * Enqueues an update caused by a signal change observed by a watch()\n     * directive.\n     *\n     * Note: the method is not part of the public API and is subject to change.\n     * In particular, it may be removed if the watch() directive is updated to\n     * work with standalone lit-html templates.\n     *\n     * @internal\n     */\n    _updateWatchDirective(d: WatchDirective<unknown>): void {\n      this.__pendingWatches.add(d);\n      // requestUpdate() will set __doFullRender to true, so remember the\n      // current value and restore it after calling requestUpdate().\n      const shouldRender = this.__doFullRender;\n      this.requestUpdate();\n      this.__doFullRender = shouldRender;\n    }\n\n    /**\n     * Clears a watch() directive from the set of pending watches.\n     *\n     * Note: the method is not part of the public API and is subject to change.\n     *\n     * @internal\n     */\n    _clearWatchDirective(d: WatchDirective<unknown>): void {\n      this.__pendingWatches.delete(d);\n    }\n  }\n  return SignalWatcher;\n}\n"],"names":["signalWatcherBrand","Symbol","elementFinalizationRegistry","FinalizationRegistry","watcher","signal","unwatch","elementForWatcher","WeakMap","SignalWatcher","Base","console","warn","constructor","this","__forceUpdateSignal","Signal","State","__forcingUpdate","__doFullRender","__pendingWatches","Set","__watch","undefined","__watcher","__performUpdateSignal","Computed","get","super","performUpdate","subtle","Watcher","el","requestUpdate","watch","set","register","__unwatch","isUpdatePending","update","changedProperties","forEach","d","commit","clear","name","oldValue","options","connectedCallback","disconnectedCallback","queueMicrotask","isConnected","_updateWatchDirective","add","shouldRender","_clearWatchDirective","delete"],"mappings":";;;;;GAyBA,MAAMA,EAAoCC,OAAO,sBAQ3CC,EAA8B,IAAIC,sBAGrC,EAAEC,UAASC,aACZD,EAAQE,QAAQD,EAAO,IAGnBE,EAAoB,IAAIC,QAUxB,SAAUC,EACdC,GAGA,OAA2D,IAAtDA,EAA8BV,IACjCW,QAAQC,KACN,yEAEKF,GAGT,cAAqCA,EAArC,WAAAG,uBAwDUC,KAAmBC,KAAG,IAAIC,EAAOC,MAAM,GAWvCH,KAAeI,MAAG,EA0BlBJ,KAAcK,MAAG,EAOjBL,KAAAM,KAAmB,IAAIC,GAkHhC,CAjNS,IAAAC,GACN,QAAuBC,IAAnBT,KAAKU,KACP,OAIFV,KAAKW,KAAwB,IAAIT,EAAOU,UAAS,KAC/CZ,KAAKC,KAAoBY,MACzBC,MAAMC,eAAe,IAEvB,MAAMzB,EAAWU,KAAKU,KAAY,IAAIR,EAAOc,OAAOC,SAAQ,WAO1D,MAAMC,EAAKzB,EAAkBoB,IAAIb,WACtBS,IAAPS,KAIuB,IAAvBA,EAAGd,MACLc,EAAGC,gBAELnB,KAAKoB,QACN,IACD3B,EAAkB4B,IAAI/B,EAASU,MAC/BZ,EAA4BkC,SAAStB,KAAM,CACzCV,UACAC,OAAQS,KAAKW,OAEfrB,EAAQ8B,MAAMpB,KAAKW,KACpB,CAEO,IAAAY,QACiBd,IAAnBT,KAAKU,OAGTV,KAAKU,KAAUlB,QAAQQ,KAAKW,MAC5BX,KAAKW,UAAwBF,EAC7BT,KAAKU,UAAYD,EAClB,CAuDkB,aAAAM,GACZf,KAAKwB,kBASVxB,KAAKQ,OAELR,KAAKI,MAAkB,EACvBJ,KAAKC,KAAoBoB,IAAIrB,KAAKC,KAAoBY,MAAQ,GAC9Db,KAAKI,MAAkB,EAEvBJ,KAAKW,KAAuBE,MAC7B,CAEkB,MAAAY,CACjBC,GAKA,IACM1B,KAAKK,MAEPL,KAAKK,MAAiB,EACtBS,MAAMW,OAAOC,IAKb1B,KAAKM,KAAiBqB,SAASC,GAAMA,EAAEC,UAE1C,CAAS,QAER7B,KAAKwB,iBAAkB,EACvBxB,KAAKM,KAAiBwB,OACvB,CACF,CAEQ,aAAAX,CACPY,EACAC,EACAC,GAEAjC,KAAKK,MAAiB,EACtBS,MAAMK,cAAcY,EAAMC,EAAUC,EACrC,CAEQ,iBAAAC,GACPpB,MAAMoB,oBAGNlC,KAAKmB,eACN,CAEQ,oBAAAgB,GACPrB,MAAMqB,uBAgBNC,gBAAe,MACY,IAArBpC,KAAKqC,aACPrC,KAAKuB,MACN,GAEJ,CAYD,CAAAe,CAAsBV,GACpB5B,KAAKM,KAAiBiC,IAAIX,GAG1B,MAAMY,EAAexC,KAAKK,KAC1BL,KAAKmB,gBACLnB,KAAKK,KAAiBmC,CACvB,CASD,CAAAC,CAAqBb,GACnB5B,KAAKM,KAAiBoC,OAAOd,EAC9B,EAGL"}