{"version":3,"file":"signal-watcher.js","sourceRoot":"","sources":["../../src/lib/signal-watcher.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {PropertyDeclaration, PropertyValueMap, ReactiveElement} from 'lit';\nimport {Signal} from 'signal-polyfill';\nimport {WatchDirective} from './watch.js';\n\ntype ReactiveElementConstructor = abstract new (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: any[]\n) => ReactiveElement;\n\nexport interface SignalWatcher extends ReactiveElement {\n  _updateWatchDirective(d: WatchDirective<unknown>): void;\n  _clearWatchDirective(d: WatchDirective<unknown>): void;\n}\n\ninterface SignalWatcherInterface extends SignalWatcher {}\ninterface SignalWatcherInternal extends SignalWatcher {\n  __forcingUpdate: boolean;\n}\n\nconst signalWatcherBrand: unique symbol = Symbol('SignalWatcherBrand');\n\n// Memory management: We need to ensure that we don't leak memory by creating a\n// reference cycle between an element and its watcher, which then it kept alive\n// by the signals it watches. To avoid this, we break the cycle by using a\n// WeakMap to store the watcher for each element, and a FinalizationRegistry to\n// clean up the watcher when the element is garbage collected.\n\nconst elementFinalizationRegistry = new FinalizationRegistry<{\n  watcher: Signal.subtle.Watcher;\n  signal: Signal.Computed<void>;\n}>(({watcher, signal}) => {\n  watcher.unwatch(signal);\n});\n\nconst elementForWatcher = new WeakMap<\n  Signal.subtle.Watcher,\n  SignalWatcherInternal\n>();\n\n/**\n * Adds the ability for a LitElement or other ReactiveElement class to\n * watch for access to signals during the update lifecycle and trigger a new\n * update when signals values change.\n */\nexport function SignalWatcher<T extends ReactiveElementConstructor>(\n  Base: T\n): T {\n  // Only apply the mixin once\n  if ((Base as typeof SignalWatcher)[signalWatcherBrand] === true) {\n    console.warn(\n      'SignalWatcher should not be applied to the same class more than once.'\n    );\n    return Base;\n  }\n\n  abstract class SignalWatcher extends Base implements SignalWatcherInterface {\n    static [signalWatcherBrand]: true;\n\n    private __watcher?: Signal.subtle.Watcher;\n\n    private __watch() {\n      if (this.__watcher !== undefined) {\n        return;\n      }\n      // We create a fresh computed instead of just re-using the existing one\n      // because of https://github.com/proposal-signals/signal-polyfill/issues/27\n      this.__performUpdateSignal = new Signal.Computed(() => {\n        this.__forceUpdateSignal.get();\n        super.performUpdate();\n      });\n      const watcher = (this.__watcher = new Signal.subtle.Watcher(function (\n        this: Signal.subtle.Watcher\n      ) {\n        // All top-level references in this function body must either be `this`\n        // (the watcher) or a module global to prevent this closure from keeping\n        // the enclosing scopes alive, which would keep the element alive. So\n        // The only two references are `this` and `elementForWatcher`.\n        const el = elementForWatcher.get(this);\n        if (el === undefined) {\n          // The element was garbage collected, so we can stop watching.\n          return;\n        }\n        if (el.__forcingUpdate === false) {\n          el.requestUpdate();\n        }\n        this.watch();\n      }));\n      elementForWatcher.set(watcher, this as unknown as SignalWatcherInternal);\n      elementFinalizationRegistry.register(this, {\n        watcher,\n        signal: this.__performUpdateSignal,\n      });\n      watcher.watch(this.__performUpdateSignal);\n    }\n\n    private __unwatch() {\n      if (this.__watcher === undefined) {\n        return;\n      }\n      this.__watcher.unwatch(this.__performUpdateSignal!);\n      this.__performUpdateSignal = undefined;\n      this.__watcher = undefined;\n    }\n\n    /**\n     * Used to force an uncached read of the __performUpdateSignal when we need\n     * to read the current value during an update.\n     *\n     * If https://github.com/tc39/proposal-signals/issues/151 is resolved, we\n     * won't need this.\n     */\n    private __forceUpdateSignal = new Signal.State(0);\n\n    /*\n     * This field is used within the watcher to determine if the watcher\n     * notification was triggered by our performUpdate() override. Because we\n     * force a fresh read of the __performUpdateSignal by changing value of the\n     * __forceUpdate signal, the watcher will be notified. But we're already\n     * performing an update, so we don't want to enqueue another one.\n     */\n    // @ts-expect-error This field is accessed in a watcher function with a\n    // different `this` context, so TypeScript can't see the access.\n    private __forcingUpdate = false;\n\n    /**\n     * A computed signal that wraps performUpdate() so that all signals that are\n     * accessed during the update lifecycle are tracked.\n     *\n     * __forceUpdateSignal is used to force an uncached read of this signal\n     * because updates may easily depend on non-signal values, so we must always\n     * re-run it.\n     */\n    private __performUpdateSignal?: Signal.Computed<void>;\n\n    /**\n     * Whether or not the next update should perform a full render, or if only\n     * pending watches should be committed.\n     *\n     * If requestUpdate() was called only because of watch() directive updates,\n     * then we can just commit those directives without a full render. If\n     * requestUpdate() was called for any other reason, we need to perform a\n     * full render, and don't need to separately commit the watch() directives.\n     *\n     * This is set to `true` initially, and whenever requestUpdate() is called\n     * outside of a watch() directive update. It is set to `false` when\n     * update() is called, so that a requestUpdate() is required to do another\n     * full render.\n     */\n    private __doFullRender = true;\n\n    /**\n     * Set of watch directives that have been updated since the last update.\n     * These will be committed in update() to ensure that the latest value is\n     * rendered and that all updates are batched.\n     */\n    private __pendingWatches = new Set<WatchDirective<unknown>>();\n\n    protected override performUpdate() {\n      if (!this.isUpdatePending) {\n        // super.performUpdate() performs this check, so we bail early so that\n        // we don't read the __performUpdateSignal when it's not going to access\n        // any signals. This keeps the last signals read as the sources so that\n        // we'll get notified of changes to them.\n        return;\n      }\n      // Always enable watching before an update, even if disconnected, so that\n      // we can track signals that are accessed during the update.\n      this.__watch();\n      // Force an uncached read of __performUpdateSignal\n      this.__forcingUpdate = true;\n      this.__forceUpdateSignal.set(this.__forceUpdateSignal.get() + 1);\n      this.__forcingUpdate = false;\n      // Always read from the signal to ensure that it's tracked\n      this.__performUpdateSignal!.get();\n    }\n\n    protected override update(\n      changedProperties: PropertyValueMap<this> | Map<PropertyKey, unknown>\n    ): void {\n      // We need a try block because both super.update() and\n      // WatchDirective.commit() can throw, and we need to ensure that post-\n      // update cleanup happens.\n      try {\n        if (this.__doFullRender) {\n          // Force future updates to not perform full renders by default.\n          this.__doFullRender = false;\n          super.update(changedProperties);\n        } else {\n          // For a partial render, just commit the pending watches.\n          // TODO (justinfagnani): Should we access each signal in a separate\n          // try block?\n          this.__pendingWatches.forEach((d) => d.commit());\n        }\n      } finally {\n        // If we didn't call super.update(), we need to set this to false\n        this.isUpdatePending = false;\n        this.__pendingWatches.clear();\n      }\n    }\n\n    override requestUpdate(\n      name?: PropertyKey | undefined,\n      oldValue?: unknown,\n      options?: PropertyDeclaration<unknown, unknown> | undefined\n    ): void {\n      this.__doFullRender = true;\n      super.requestUpdate(name, oldValue, options);\n    }\n\n    override connectedCallback(): void {\n      super.connectedCallback();\n      // Because we might have missed some signal updates while disconnected,\n      // we force a full render on the next update.\n      this.requestUpdate();\n    }\n\n    override disconnectedCallback(): void {\n      super.disconnectedCallback();\n      // Clean up the watcher earlier than the FinalizationRegistry will, to\n      // avoid memory pressure from signals holding references to the element\n      // via the watcher.\n      //\n      // This means that while disconnected, regular reactive property updates\n      // will trigger a re-render, but signal updates will not. To ensure that\n      // current signal usage is still correctly tracked, we re-enable watching\n      // in performUpdate() even while disconnected. From that point on, a\n      // disconnected element will be retained by the signals it accesses during\n      // the update lifecycle.\n      //\n      // We use queueMicrotask() to ensure that this cleanup does not happen\n      // because of moves in the DOM within the same task, such as removing an\n      // element with .remove() and then adding it back later with .append()\n      // in the same task. For example, repeat() works this way.\n      queueMicrotask(() => {\n        if (this.isConnected === false) {\n          this.__unwatch();\n        }\n      });\n    }\n\n    /**\n     * Enqueues an update caused by a signal change observed by a watch()\n     * directive.\n     *\n     * Note: the method is not part of the public API and is subject to change.\n     * In particular, it may be removed if the watch() directive is updated to\n     * work with standalone lit-html templates.\n     *\n     * @internal\n     */\n    _updateWatchDirective(d: WatchDirective<unknown>): void {\n      this.__pendingWatches.add(d);\n      // requestUpdate() will set __doFullRender to true, so remember the\n      // current value and restore it after calling requestUpdate().\n      const shouldRender = this.__doFullRender;\n      this.requestUpdate();\n      this.__doFullRender = shouldRender;\n    }\n\n    /**\n     * Clears a watch() directive from the set of pending watches.\n     *\n     * Note: the method is not part of the public API and is subject to change.\n     *\n     * @internal\n     */\n    _clearWatchDirective(d: WatchDirective<unknown>): void {\n      this.__pendingWatches.delete(d);\n    }\n  }\n  return SignalWatcher;\n}\n"]}